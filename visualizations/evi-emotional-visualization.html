<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Evi's Emotional Pattern Analysis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: rgb(240, 245, 250);
            font-family: 'Roboto Mono', monospace;
            -webkit-text-size-adjust: 100%;
            touch-action: none;
        }
        
        /* Landing page */
        #landing-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        /* Grid background */
        .grid-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(#20B2AA 1px, transparent 1px),
                              linear-gradient(90deg, #20B2AA 1px, transparent 1px),
                              linear-gradient(#FFB6C1 1px, transparent 1px),
                              linear-gradient(90deg, #FFB6C1 1px, transparent 1px),
                              linear-gradient(rgba(32, 178, 170, 0.3) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(32, 178, 170, 0.3) 1px, transparent 1px);
            background-size: 20px 20px,
                             20px 20px,
                             100px 100px,
                             100px 100px, 
                             5px 5px,
                             5px 5px;
            z-index: -1;
        }
        
        /* Content box */
        .content-box {
            max-width: 500px;
            padding: 25px;
            background-color: rgba(255, 255, 255, 0.85);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            text-align: center;
            z-index: 1;
        }
        
        .title {
            color: #FFB6C1;
            margin-bottom: 15px;
            font-size: 20px;
            font-weight: 500;
            letter-spacing: 1px;
        }
        
        .description {
            color: #444;
            line-height: 1.5;
            margin-bottom: 15px;
            font-size: 14px;
        }
        
        .start-button {
            padding: 12px 24px;
            background-color: #20B2AA;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
            font-family: 'Roboto Mono', monospace;
            transition: all 0.3s ease;
            letter-spacing: 0.5px;
        }
        
        .start-button:hover {
            background-color: #FFB6C1;
            transform: translateY(-2px);
        }
        
        .start-button:active {
            transform: scale(0.98);
        }
        
        .gesture-container {
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
        }
        
        .gesture-outline {
            width: 80px;
            height: 80px;
            border: 2px solid #FFB6C1;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0.8;
        }
        
        /* Wave icon for Evi */
        .gesture-icon {
            width: 50px;
            height: 50px;
            position: relative;
        }
        
        .gesture-icon::before,
        .gesture-icon::after {
            content: "";
            position: absolute;
        }
        
        .gesture-icon::before {
            width: 40px;
            height: 15px;
            top: 12px;
            left: 5px;
            border-radius: 50%;
            background: transparent;
            border-bottom: 3px solid #FFB6C1;
            transform: rotate(-5deg);
        }
        
        .gesture-icon::after {
            width: 40px;
            height: 10px;
            top: 24px;
            left: 5px;
            border-radius: 50%;
            background: transparent;
            border-bottom: 3px solid #20B2AA;
            transform: rotate(-2deg);
        }
        
        /* Loading indicator - CRITICAL CHANGES HERE */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgb(240, 245, 250);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            display: none;
            font-family: 'Roboto Mono', monospace;
            color: #20B2AA;
        }
        
        /* Visualization container */
        #visualization-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: none; /* Initially hidden */
        }
        
        /* Help message at the bottom */
        .help-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 182, 193, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            z-index: 200;
            text-align: center;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- Landing page -->
    <div id="landing-page">
        <div class="grid-background"></div>
        
        <div class="content-box">
            <div class="gesture-container">
                <div class="gesture-outline">
                    <div class="gesture-icon"></div>
                </div>
            </div>
            
            <h1 class="title">Evi: Emotional Pattern Analysis</h1>
            
            <p class="description">
                Observe Evi's emotional information processing system. This visualization demonstrates how Evi analyzes patterns through waves of emotional resonance, creating intuitive connections between emotional centers.
            </p>
            
            <p class="description">
                Through this interactive experience, you'll witness Evi's empathetic approach to gathering, recognizing, and synthesizing emotional information--prioritizing meaningful connections and insightful patterns.
            </p>
            
            <button id="start-button" class="start-button">BEGIN INTERACTION</button>
        </div>
    </div>
    
    <!-- Loading screen -->
    <div id="loading-screen">
        <h2>Loading...</h2>
        <p>Preparing visualization</p>
    </div>
    
    <!-- Visualization container -->
    <div id="visualization-container"></div>
    
    <script>
        // Global variables
        let p5Instance = null;
        
        // Hand animation configuration
        const handAnimation = {
            frameCount: 6,
            currentFrame: 0,
            frameDuration: 100,
            opacity: 0.85,
            x: 0,
            y: 0,
            size: 250,
            frameImages: [],
            isPlaying: true,
            rotationOffset: 0,
            rotationSpeed: 0.001,
            lastFrameTime: 0
        };
        
        // Start button event listener
        document.getElementById('start-button').addEventListener('click', startExperience);
        
        // Function to start the experience
        function startExperience() {
            console.log("Starting experience...");
            
            // CRITICAL: First hide landing page completely
            document.getElementById('landing-page').style.display = 'none';
            
            // Then show loading screen
            document.getElementById('loading-screen').style.display = 'flex';
            
            // After a delay, initialize visualization and show container
            setTimeout(function() {
                // Show visualization container
                document.getElementById('visualization-container').style.display = 'block';
                
                // Initialize the p5 sketch
                try {
                    console.log("Initializing p5 sketch...");
                    new p5(eviSketch, 'visualization-container');
                } catch (error) {
                    console.error("Error initializing p5:", error);
                    // Hide loading screen if there's an error
                    document.getElementById('loading-screen').style.display = 'none';
                }
            }, 500);
            
            // Backup timeout to force hide loading screen after 5 seconds
            setTimeout(function() {
                document.getElementById('loading-screen').style.display = 'none';
                console.log("Force hiding loading screen after timeout");
            }, 5000);
        }
        
        // Function to update hand animation frames
        function updateHandAnimation() {
            const anim = handAnimation;
            
            // Update rotation for gentle movement
            anim.rotationOffset += anim.rotationSpeed;
            
            // Advance to next frame based on timing
            setTimeout(() => {
                anim.currentFrame = (anim.currentFrame + 1) % anim.frameCount;
                
                // Continue animation
                requestAnimationFrame(updateHandAnimation);
            }, anim.frameDuration);
        }
        
        // Start animation loop
        updateHandAnimation();
        
        // Evi's visualization sketch
        const eviSketch = function(p) {
            // Store reference to the p5 instance
            p5Instance = p;
            
            // Visualization elements
            let waves = [];
            let emotionalCenters = [];
            let flowParticles = [];
            let moodColor;
            let intensityLevel = 0.5;
            let thoughtfulness = 0.5;
            
            // Sound elements
            let interactionSound = null;
            let lastSoundTime = 0;
            
            // Color palettes
            const INTENSE_COLOR = [255, 182, 193];   // Light pink (#FFB6C1)
            const CALM_COLOR = [32, 178, 170];      // Light sea green (#20B2AA)
            const NEUTRAL_COLOR = [143, 188, 187];  // Blend of the two colors
            
            // Help messages
            let helpMessages = [
                "Tap anywhere to create an emotional center",
                "Drag to create a stream of emotional energy"
            ];
            let activeHelpMessageIndex = 0;
            
            p.preload = function() {
                console.log("Preloading assets...");
                
                // Try to load hand animation frames - NON-BLOCKING
                try {
                    for (let i = 1; i <= handAnimation.frameCount; i++) {
                        // Load animation frames but don't wait for them
                        p.loadImage(
                            `evi-hand${i}.png`,
                            img => {
                                handAnimation.frameImages[i-1] = img;
                                console.log(`Loaded hand frame ${i}`);
                            },
                            () => {
                                console.log(`Failed to load hand frame ${i}, creating placeholder`);
                                // Create placeholder image
                                const placeholder = p.createGraphics(200, 200);
                                placeholder.background(255, 255, 255, 0);
                                placeholder.fill(255, 182, 193, 100);
                                placeholder.noStroke();
                                placeholder.ellipse(100, 100, 150, 150);
                                handAnimation.frameImages[i-1] = placeholder;
                            }
                        );
                    }
                } catch(e) {
                    console.log("Error loading animation frames:", e);
                    // Create empty placeholders
                    for (let i = 0; i < handAnimation.frameCount; i++) {
                        const placeholder = p.createGraphics(200, 200);
                        placeholder.background(255, 255, 255, 0);
                        placeholder.fill(255, 182, 193, 100);
                        placeholder.noStroke();
                        placeholder.ellipse(100, 100, 150, 150);
                        handAnimation.frameImages.push(placeholder);
                    }
                }
                
                // Try to load sound - NON-BLOCKING
                try {
                    p.soundFormats('mp3', 'wav');
                    p.loadSound(
                        'evi-confusion-sound.mp3',
                        sound => {
                            interactionSound = sound;
                            console.log("Sound loaded successfully");
                        },
                        err => {
                            console.log("Error loading sound:", err);
                        }
                    );
                } catch(e) {
                    console.log("Error in sound preload:", e);
                }
            };
            
            // Helper function to play sound - with robust error handling
            function playSound() {
                try {
                    // Only play sound if enough time has passed since last play
                    if (!lastSoundTime || Date.now() - lastSoundTime > 2000) {
                        if (interactionSound && interactionSound.isLoaded()) {
                            // Make sure audio context is running
                            p.userStartAudio().then(() => {
                                interactionSound.setVolume(0.5);
                                interactionSound.play();
                                lastSoundTime = Date.now();
                                console.log("Sound played");
                            }).catch(e => {
                                console.log("Error starting audio:", e);
                            });
                        }
                    }
                } catch(e) {
                    console.log("Error playing sound:", e);
                }
            }
            
            // Draw hand animation frame
            function drawHandAnimationFrame() {
                try {
                    const anim = handAnimation;
                    
                    if (anim.frameImages.length > 0 && anim.frameImages[anim.currentFrame]) {
                        p.push();
                        
                        // Apply gentle rotation around center
                        p.translate(anim.x, anim.y);
                        p.rotate(anim.rotationOffset);
                        p.translate(-anim.x, -anim.y);
                        
                        // First draw a visual indicator/background
                        p.noStroke();
                        
                        // Create a blurred background for better visibility
                        for (let i = 0; i < 3; i++) {
                            const blurOpacity = anim.opacity * (100 - i * 20);
                            const blurSize = anim.size * (1.05 + i * 0.04);
                            p.fill(255, 255, 255, blurOpacity);
                            p.ellipse(anim.x, anim.y, blurSize);
                        }
                        
                        // Get the current frame image
                        const img = anim.frameImages[anim.currentFrame];
                        
                        if (img) {
                            // Calculate height preserving aspect ratio
                            const aspectRatio = img.height / img.width || 1;
                            const drawHeight = anim.size * aspectRatio;
                            
                            // Draw the image
                            p.tint(255, 255, 255, Math.min(255, anim.opacity * 255));
                            p.image(
                                img,
                                anim.x - anim.size/2,
                                anim.y - drawHeight/2,
                                anim.size,
                                drawHeight
                            );
                        }
                        
                        p.pop();
                    } else {
                        // Draw fallback if no image is available
                        p.push();
                        p.noStroke();
                        p.fill(255, 182, 193, 100);
                        p.ellipse(anim.x, anim.y, 150);
                        p.pop();
                    }
                } catch(e) {
                    console.log("Error drawing animation frame:", e);
                    
                    // Simple fallback
                    p.push();
                    p.noStroke();
                    p.fill(255, 182, 193, 100);
                    p.ellipse(handAnimation.x, handAnimation.y, 150);
                    p.pop();
                }
            }
            
            p.setup = function() {
                console.log("p5 setup starting...");
                
                // Create canvas
                p.createCanvas(p.windowWidth, p.windowHeight);
                
                // Initialize waves
                for (let i = 0; i < 8; i++) {
                    waves.push({
                        baseHeight: p.height * (0.3 + i * 0.05),
                        amplitude: p.random(20, 50),
                        frequency: p.random(0.005, 0.02),
                        speed: p.random(0.01, 0.03),
                        phase: i * 0.5,
                        color: [...NEUTRAL_COLOR, 180],
                        thickness: p.random(1, 3)
                    });
                }
                
                // Start with neutral mood
                moodColor = NEUTRAL_COLOR;
                
                // Create a few initial emotional centers
                for (let i = 0; i < 3; i++) {
                    emotionalCenters.push({
                        x: p.random(p.width * 0.2, p.width * 0.8),
                        y: p.random(p.height * 0.3, p.height * 0.7),
                        size: p.random(20, 60),
                        intensity: p.random(0.5, 1),
                        lifetime: 0,
                        maxLifetime: p.random(120, 240),
                        color: [...NEUTRAL_COLOR, 150]
                    });
                }
                
                // Set hand animation position to center of canvas
                handAnimation.x = p.width / 2;
                handAnimation.y = p.height / 2;
                
                // CRITICAL: Create help message elements
                createHelpMessages();
                
                // Try to initialize audio context
                try {
                    p.userStartAudio().catch(e => {
                        console.log("Audio will be initialized on user interaction");
                    });
                } catch(e) {
                    console.log("Audio initialization error:", e);
                }
                
                // CRITICAL: Hide loading screen now that setup is complete
                document.getElementById('loading-screen').style.display = 'none';
                
                console.log("p5 setup complete");
            };
            
            // Create help messages
            function createHelpMessages() {
                // Remove any existing help messages
                const existingMessages = document.querySelectorAll('.help-message');
                existingMessages.forEach(msg => msg.remove());
                
                // Create new help messages
                helpMessages.forEach((text, index) => {
                    const msgElement = document.createElement('div');
                    msgElement.className = 'help-message';
                    msgElement.textContent = text;
                    msgElement.style.display = index === activeHelpMessageIndex ? 'block' : 'none';
                    document.body.appendChild(msgElement);
                });
            }
            
            // Change the active help message
            function changeHelpMessage() {
                const messages = document.querySelectorAll('.help-message');
                if (messages.length > 0) {
                    messages.forEach((msg, index) => {
                        msg.style.display = index === activeHelpMessageIndex ? 'block' : 'none';
                    });
                    
                    // Cycle to next message
                    activeHelpMessageIndex = (activeHelpMessageIndex + 1) % helpMessages.length;
                }
            }
            
            p.draw = function() {
                // Semi-transparent background for trail effect
                p.background(240, 245, 250, 20);
                
                // Update emotional state
                intensityLevel = 0.5 + 0.4 * Math.sin(p.frameCount * 0.01);
                thoughtfulness = 0.5 + 0.4 * Math.sin(p.frameCount * 0.007 + 1);
                
                // Update mood color
                moodColor = [
                    p.lerp(CALM_COLOR[0], INTENSE_COLOR[0], intensityLevel),
                    p.lerp(CALM_COLOR[1], INTENSE_COLOR[1], intensityLevel),
                    p.lerp(CALM_COLOR[2], INTENSE_COLOR[2], intensityLevel)
                ];
                
                // Occasionally create new emotional centers
                if (p.frameCount % 60 === 0 && p.random() < 0.3) {
                    emotionalCenters.push({
                        x: p.random(p.width * 0.2, p.width * 0.8),
                        y: p.random(p.height * 0.3, p.height * 0.7),
                        size: p.random(20, 60),
                        intensity: p.random(0.5, 1),
                        lifetime: 0,
                        maxLifetime: p.random(120, 240),
                        color: [...moodColor, 150]
                    });
                }
                
                // Update and draw waves
                for (let wave of waves) {
                    // Update wave properties
                    wave.phase += wave.speed * (0.5 + intensityLevel * 1.5);
                    wave.currentAmplitude = wave.amplitude * (0.8 + intensityLevel * 0.8);
                    wave.color = [...moodColor, 180 * (0.7 + 0.3 * (1 - thoughtfulness))];
                    wave.currentThickness = wave.thickness * (0.8 + 0.8 * (1 - thoughtfulness));
                    
                    // Draw wave
                    p.stroke(wave.color);
                    p.strokeWeight(wave.currentThickness);
                    p.noFill();
                    p.beginShape();
                    for (let x = 0; x < p.width; x += 5) {
                        const y = wave.baseHeight + 
                                wave.currentAmplitude * Math.sin(x * wave.frequency + wave.phase) +
                                wave.currentAmplitude * 0.5 * Math.sin(x * wave.frequency * 2 + wave.phase * 1.5);
                        p.vertex(x, y);
                    }
                    p.endShape();
                }
                
                // Update and draw emotional centers
                for (let i = emotionalCenters.length - 1; i >= 0; i--) {
                    const center = emotionalCenters[i];
                    
                    // Update lifetime
                    center.lifetime++;
                    
                    // Calculate opacity based on lifetime
                    const opacity = center.lifetime < center.maxLifetime * 0.2 
                        ? p.map(center.lifetime, 0, center.maxLifetime * 0.2, 0, 150)
                        : p.map(center.lifetime, center.maxLifetime * 0.2, center.maxLifetime, 150, 0);
                    
                    // Pulsating effect
                    const pulseSize = center.size * (0.8 + 0.4 * Math.sin(center.lifetime * 0.05));
                    
                    // Draw glow
                    for (let j = 3; j >= 0; j--) {
                        p.fill(center.color[0], center.color[1], center.color[2], opacity * (0.3 - j * 0.07));
                        p.noStroke();
                        p.ellipse(center.x, center.y, pulseSize * (1.2 + j * 0.2), pulseSize * (1.2 + j * 0.2));
                    }
                    
                    // Draw core
                    p.fill(center.color[0], center.color[1], center.color[2], opacity);
                    p.ellipse(center.x, center.y, pulseSize, pulseSize);
                    
                    // Remove if expired
                    if (center.lifetime >= center.maxLifetime) {
                        emotionalCenters.splice(i, 1);
                    }
                }
                
                // Draw connections between emotional centers
                if (emotionalCenters.length > 1) {
                    for (let i = 0; i < emotionalCenters.length; i++) {
                        for (let j = i + 1; j < emotionalCenters.length; j++) {
                            const c1 = emotionalCenters[i];
                            const c2 = emotionalCenters[j];
                            
                            // Calculate distance
                            const d = p.dist(c1.x, c1.y, c2.x, c2.y);
                            
                            // Only connect if not too far
                            if (d < p.width * 0.4) {
                                // Calculate connection strength based on distance
                                const strength = p.map(d, 0, p.width * 0.4, 0.8, 0);
                                
                                // Draw connection with varying opacity
                                p.stroke(moodColor[0], moodColor[1], moodColor[2], 100 * strength);
                                p.strokeWeight(1 + 2 * strength);
                                
                                // Draw curved line with flowing animation
                                p.noFill();
                                p.beginShape();
                                const steps = 20;
                                for (let t = 0; t <= steps; t++) {
                                    const progress = t / steps;
                                    
                                    // Calculate point along curve with some vertical displacement
                                    const x = p.lerp(c1.x, c2.x, progress);
                                    const displacement = Math.sin(progress * Math.PI) * 30 * 
                                                      Math.sin(p.frameCount * 0.05 + i * 0.5 + j * 0.5);
                                    const y = p.lerp(c1.y, c2.y, progress) + displacement;
                                    
                                    p.vertex(x, y);
                                }
                                p.endShape();
                                
                                // Add moving particles along the connection
                                if (p.frameCount % 10 === 0 && p.random() < 0.3 * intensityLevel) {
                                    flowParticles.push({
                                        startX: c1.x,
                                        startY: c1.y,
                                        endX: c2.x,
                                        endY: c2.y,
                                        progress: 0,
                                        speed: p.random(0.01, 0.03) * (0.5 + intensityLevel),
                                        size: p.random(3, 6),
                                        color: [...moodColor, 200]
                                    });
                                }
                            }
                        }
                    }
                }
                
                // Update and draw flow particles
                for (let i = flowParticles.length - 1; i >= 0; i--) {
                    const particle = flowParticles[i];
                    
                    // Update progress
                    particle.progress += particle.speed;
                    
                    // Calculate current position
                    const x = p.lerp(particle.startX, particle.endX, particle.progress);
                    const y = p.lerp(particle.startY, particle.endY, particle.progress);
                    
                    // Draw particle
                    p.noStroke();
                    p.fill(particle.color);
                    p.ellipse(x, y, particle.size, particle.size);
                    
                    // Remove if completed journey
                    if (particle.progress >= 1) {
                        flowParticles.splice(i, 1);
                    }
                }
                
                // Draw hand animation in the center
                drawHandAnimationFrame();
                
                // Occasionally change help message
                if (p.frameCount % 300 === 0) {
                    changeHelpMessage();
                }
            };
            
            // Mouse/touch interaction
            p.mousePressed = function() {
                if (p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height) {
                    // Create an emotional center at mouse position
                    emotionalCenters.push({
                        x: p.mouseX,
                        y: p.mouseY,
                        size: p.random(30, 70),
                        intensity: 1.0,
                        lifetime: 0,
                        maxLifetime: p.random(180, 300),
                        color: [...INTENSE_COLOR, 180]
                    });
                    
                    // Try to play sound
                    playSound();
                    
                    return false; // Prevent default
                }
            };
            
            p.mouseDragged = function() {
                if (p.frameCount % 5 === 0) { // Limit creation rate
                    emotionalCenters.push({
                        x: p.mouseX,
                        y: p.mouseY,
                        size: p.random(15, 40),
                        intensity: 0.7,
                        lifetime: 0,
                        maxLifetime: p.random(60, 120),
                        color: [...moodColor, 150]
                    });
                }
                
                // Increase intensity when dragging
                intensityLevel = Math.min(1, intensityLevel + 0.02);
                
                return false; // Prevent default
            };
            
            p.doubleClicked = function() {
                // Reset visualization
                emotionalCenters = [];
                intensityLevel = 0.5;
                thoughtfulness = 0.5;
                return false; // Prevent default
            };
            
            p.windowResized = function() {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
                
                // Adjust wave base heights
                for (let i = 0; i < waves.length; i++) {
                    waves[i].baseHeight = p.height * (0.3 + i * 0.05);
                }
                
                // Update hand animation position
                handAnimation.x = p.width / 2;
                handAnimation.y = p.height / 2;
            };
            
            // Touch support for mobile
            p.touchStarted = function() {
                try {
                    if (p.touches.length > 0 && p.touches[0]) {
                        // Try to initialize audio on first touch
                        p.userStartAudio();
                        
                        // Get touch coordinates
                        const touchX = p.touches[0].x || p.touches[0].clientX || 0;
                        const touchY = p.touches[0].y || p.touches[0].clientY || 0;
                        
                        // Create an emotional center
                        if (touchX > 0 && touchX < p.width && touchY > 0 && touchY < p.height) {
                            emotionalCenters.push({
                                x: touchX,
                                y: touchY,
                                size: p.random(30, 70),
                                intensity: 1.0,
                                lifetime: 0,
                                maxLifetime: p.random(180, 300),
                                color: [...INTENSE_COLOR, 180]
                            });
                            
                            // Try to play sound
                            playSound();
                        }
                    }
                } catch(e) {
                    console.log("Error in touchStarted:", e);
                }
                
                return false; // Prevent default
            };
            
            p.touchMoved = function() {
                try {
                    if (p.touches.length > 0 && p.touches[0]) {
                        // Get touch coordinates
                        const touchX = p.touches[0].x || p.touches[0].clientX || 0;
                        const touchY = p.touches[0].y || p.touches[0].clientY || 0;
                        
                        // Add emotional centers along the drag path (but not too many)
                        if (p.frameCount % 5 === 0) {
                            emotionalCenters.push({
                                x: touchX,
                                y: touchY,
                                size: p.random(15, 40),
                                intensity: 0.7,
                                lifetime: 0,
                                maxLifetime: p.random(60, 120),
                                color: [...moodColor, 150]
                            });
                            
                            // Increase intensity when dragging
                            intensityLevel = Math.min(1, intensityLevel + 0.02);
                            
                            // Occasionally play sound during dragging
                            if (p.frameCount % 30 === 0) {
                                playSound();
                            }
                        }
                    }
                } catch(e) {
                    console.log("Error in touchMoved:", e);
                }
                
                return false; // Prevent default
            };
        };
        
        // Prevent default touch behaviors ONLY after landing page is dismissed
        document.addEventListener('touchmove', function(e) {
            if (document.getElementById('landing-page').style.display === 'none') {
                e.preventDefault();
            }
        }, { passive: false });
        
        document.addEventListener('touchstart', function(e) {
            if (document.getElementById('landing-page').style.display === 'none' && 
                !e.target.closest('#start-button')) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>
