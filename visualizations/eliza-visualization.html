<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ELIZA's Information Processing Visualization</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            background-color: #f9f2e2;
            background-image: 
                linear-gradient(#ccc 1px, transparent 1px),
                linear-gradient(90deg, #ccc 1px, transparent 1px);
            background-size: 20px 20px;
            min-height: 100vh;
        }
        
        /* Back button */
        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            background-color: #f9f2e2;
            color: #2c3e50;
            text-decoration: none;
            border: 2px dotted #2980b9;
            border-radius: 12px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .back-button:hover {
            background-color: #f5e9c9;
            transform: translateX(-3px);
            box-shadow: 0 3px 12px rgba(0,0,0,0.15);
        }
        
        .back-arrow {
            font-size: 14px;
            transition: transform 0.3s ease;
        }
        
        .back-button:hover .back-arrow {
            transform: translateX(-3px);
        }
        
        /* Main container */
        .main-container {
            display: flex;
            flex-direction: row;
            min-height: 100vh;
            padding-top: 70px; /* Space for back button */
        }
        
        /* Grid container (left side) */
        .grid-container {
            width: 45%;
            min-height: calc(100vh - 70px);
            background-color: #f9f2e2;
            background-image: 
                linear-gradient(#ccc 1px, transparent 1px),
                linear-gradient(90deg, #ccc 1px, transparent 1px);
            background-size: 20px 20px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }
        
        /* Visualization container (right side) */
        .visualization-container {
            width: 55%;
            height: calc(100vh - 70px);
            position: sticky;
            top: 70px;
            background-color: rgb(250, 250, 250);
            border-left: 2px dotted #2980b9;
        }
        
        /* Info boxes styling */
        .info-box {
            background-color: #f9f2e2;
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            border: 2px dotted #2980b9;
        }
        
        h1 {
            color: #2c3e50;
            font-size: 20px;
            margin-top: 0;
            margin-bottom: 10px;
            font-family: 'Courier New', Courier, monospace;
            text-align: center;
            border-bottom: 2px dotted #3498db;
            padding-bottom: 10px;
        }
        
        h3 {
            margin-top: 0;
            color: #2c3e50;
            font-size: 14px;
            font-family: 'Courier New', Courier, monospace;
            border-bottom: 2px dotted #3498db;
            padding-bottom: 8px;
        }
        
        p {
            color: #2c3e50;
            line-height: 1.6;
            font-size: 13px;
            margin: 0 0 10px 0;
        }
        
        /* Interaction tips */
        .interaction-tips {
            background-color: #f5e9c9;
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            border: 2px dotted #2980b9;
        }
        
        .interaction-tips ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .interaction-tips li {
            margin-bottom: 10px;
            font-size: 13px;
            color: #2c3e50;
            font-family: 'Courier New', Courier, monospace;
            line-height: 1.5;
        }
        
        .interaction-tips li strong {
            color: #3498db;
        }
        
        /* Info section */
        .info {
            background-color: #f9f2e2;
            padding: 15px;
            border-radius: 15px;
            font-family: 'Courier New', Courier, monospace;
            color: #2c3e50;
            font-size: 12px;
            border: 2px dashed #3498db;
            line-height: 1.6;
            margin-top: auto;
        }
        
        .info p {
            margin-bottom: 8px;
        }
        
        .info p:last-child {
            margin-bottom: 0;
        }
        
        .info strong {
            color: #3498db;
        }
        
        /* Context section */
        .context-section {
            background-color: #f9f2e2;
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            border: 2px dotted #2980b9;
        }
        
        .context-section h3 {
            margin-bottom: 12px;
        }
        
        .highlight {
            background-color: rgba(52, 152, 219, 0.15);
            padding: 2px 6px;
            border-radius: 4px;
        }

                /* Mobile layout */
        @media (max-width: 900px) {
            .main-container {
                flex-direction: column;
                padding-top: 60px;
            }
            
            .back-button {
                top: 10px;
                left: 10px;
                padding: 8px 14px;
                font-size: 12px;
            }
            
            .grid-container {
                width: 100%;
                min-height: auto;
                order: 1; /* Changed: text first on mobile */
            }
            
            .visualization-container {
                width: 100%;
                height: 60vh;
                min-height: 300px;
                position: relative;
                top: 0;
                order: 2; /* Changed: visualization second on mobile */
                border-left: none;
                border-top: 2px dotted #2980b9; /* Changed to top border */
            }
            
            h1 {
                font-size: 18px;
            }
            
            .interaction-tips li {
                font-size: 12px;
            }
            
            .info {
                font-size: 11px;
            }
        }

        @media (max-width: 480px) {
            .main-container {
                padding-top: 55px;
            }
            
            .back-button {
                padding: 6px 12px;
                font-size: 11px;
            }
            
            .grid-container {
                padding: 15px;
            }
            
            .visualization-container {
                height: 50vh;
                min-height: 280px;
            }
            
            h1 {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <!-- Back Button -->
    <a href="ai-information-processing.html" class="back-button">
        <span class="back-arrow">←</span>
        <span>Back to AI Processing</span>
    </a>
    
    <div class="main-container">
        <!-- Grid area (left side) -->
        <div class="grid-container">
            <div class="info-box">
                <h1>ELIZA's Information Processing</h1>
                <p>A visualization exploring the pattern-matching nature of early conversational AI, demonstrating how rule-based systems process information without true understanding or self-reference.</p>
            </div>
            
            <div class="interaction-tips">
                <h3>Interact with the Visualization:</h3>
                <ul>
                    <li><strong>Click:</strong> Ask a question (creates reflection point)</li>
                    <li><strong>Drag:</strong> See how ELIZA redirects attention</li>
                    <li><strong>Double-click:</strong> Reset the visualization</li>
                </ul>
            </div>
            
            <div class="context-section">
                <h3>Understanding ELIZA</h3>
                <p>ELIZA was created by Joseph Weizenbaum in 1966 as one of the first programs capable of attempting the Turing test. It used <span class="highlight">pattern matching</span> and <span class="highlight">substitution methodology</span> to simulate conversation.</p>
                <p>The visualization represents ELIZA's fundamental limitation: it has no model of self. When asked direct questions about its nature, ELIZA consistently redirects focus back to the user—not as an evasion, but because redirection is the only response possible for a system without self-reference capability.</p>
            </div>
            
            <div class="context-section">
                <h3>Visual Elements</h3>
                <p><strong>Question marks (?):</strong> Represent the constant deflection of inquiry</p>
                <p><strong>Mirror frame:</strong> Symbolizes reflection without self-awareness</p>
                <p><strong>Ripple effects:</strong> Show how input disperses without being truly processed</p>
                <p><strong>Redirecting arrows:</strong> Illustrate attention being pushed outward</p>
                <p><strong>Echo text:</strong> ELIZA's actual responses, fading as they reveal nothing</p>
            </div>
            
            <!-- Info box -->
            <div class="info">
                <p><strong>About This Visualization</strong></p>
                <p>ELIZA's redirections aren't evasions—they're the only responses possible for a system with no capacity for self-reference. The grayscale palette represents the absence of internal experience, while the mirror frame suggests reflection without genuine self-perception.</p>
                <p>This visualization is part of the exploration into different AI modes of perception for "The Uncanny Valley" installation.</p>
            </div>
        </div>
        
        <!-- Visualization container (right side) -->
        <div class="visualization-container" id="visualization-container"></div>
    </div>

    <!-- Load p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    
    <script>
        // Create a new p5 instance for the visualization
        const elizaSketch = function(p) {
            // Core elements
            let reflectionPoints = [];
            let redirectArrows = [];
            let questionMarks = [];
            let echoText = [];
            let mirrorFrame;
            
            // Text responses from ELIZA
            const elizaResponses = [
                "What does that suggest to you?",
                "Please go on.",
                "Does that trouble you?",
                "Tell me more about that.",
                "We were discussing you—not me.",
                "Is it because you are that you came to me?",
                "How does that make you feel?",
                "Why do you ask?",
                "I see.",
                "And how does that relate to you?"
            ];
            
            // Colors - grayscale to represent emptiness
            const FRAME_COLOR = [150, 150, 150];
            const QUESTION_COLOR = [100, 100, 100];
            const REFLECTION_COLOR = [180, 180, 180];
            
            p.setup = function() {
                let container = document.getElementById('visualization-container');
                p.createCanvas(container.offsetWidth, container.offsetHeight);
                
                mirrorFrame = {
                    x: p.width * 0.5,
                    y: p.height * 0.5,
                    width: p.width * 0.7,
                    height: p.height * 0.7,
                    borderThickness: 20,
                    opacity: 180
                };
                
                for (let i = 0; i < 8; i++) {
                    addQuestionMark();
                }
            };
            
            p.draw = function() {
                p.background(250, 250, 250, 30);
                drawMirrorFrame();
                updateAndDrawReflectionPoints();
                updateAndDrawRedirectArrows();
                updateAndDrawQuestionMarks();
                updateAndDrawEchoText();
            };
            
            function drawMirrorFrame() {
                const pulseAmount = 5 * Math.sin(p.frameCount * 0.02);
                const currentThickness = mirrorFrame.borderThickness + pulseAmount;
                
                p.noFill();
                p.strokeWeight(currentThickness);
                p.stroke(...FRAME_COLOR, mirrorFrame.opacity);
                p.rect(
                    mirrorFrame.x - mirrorFrame.width/2, 
                    mirrorFrame.y - mirrorFrame.height/2, 
                    mirrorFrame.width, 
                    mirrorFrame.height,
                    10
                );
                
                p.fill(255, 255, 255, 5);
                p.noStroke();
                p.rect(
                    mirrorFrame.x - mirrorFrame.width/2 + currentThickness/2, 
                    mirrorFrame.y - mirrorFrame.height/2 + currentThickness/2, 
                    mirrorFrame.width - currentThickness, 
                    mirrorFrame.height - currentThickness,
                    5
                );
            }
            
            function addReflectionPoint(x, y) {
                reflectionPoints.push({
                    x: x,
                    y: y,
                    size: 10,
                    maxSize: p.random(80, 150),
                    opacity: 200,
                    speed: p.random(0.5, 2),
                    alive: true
                });
                
                addEchoText(x, y);
                addRedirectionArrows(x, y);
            }
            
            function updateAndDrawReflectionPoints() {
                for (let i = reflectionPoints.length - 1; i >= 0; i--) {
                    const point = reflectionPoints[i];
                    
                    point.size += point.speed;
                    point.opacity = p.map(point.size, 0, point.maxSize, 200, 0);
                    
                    p.noFill();
                    p.stroke(REFLECTION_COLOR[0], REFLECTION_COLOR[1], REFLECTION_COLOR[2], point.opacity);
                    p.strokeWeight(1);
                    p.ellipse(point.x, point.y, point.size, point.size);
                    
                    if (point.size >= point.maxSize) {
                        reflectionPoints.splice(i, 1);
                    }
                }
            }
            
            function addRedirectionArrows(x, y) {
                const numArrows = p.floor(p.random(4, 8));
                for (let i = 0; i < numArrows; i++) {
                    const angle = (i / numArrows) * p.TWO_PI;
                    const length = p.random(40, 100);
                    
                    redirectArrows.push({
                        startX: x,
                        startY: y,
                        angle: angle,
                        length: length,
                        progress: 0,
                        speed: p.random(0.01, 0.04),
                        opacity: 200
                    });
                }
            }
            
            function updateAndDrawRedirectArrows() {
                for (let i = redirectArrows.length - 1; i >= 0; i--) {
                    const arrow = redirectArrows[i];
                    
                    arrow.progress += arrow.speed;
                    arrow.opacity = p.map(arrow.progress, 0, 1, 200, 0);
                    
                    const currentLength = arrow.length * arrow.progress;
                    const endX = arrow.startX + Math.cos(arrow.angle) * currentLength;
                    const endY = arrow.startY + Math.sin(arrow.angle) * currentLength;
                    
                    p.stroke(FRAME_COLOR[0], FRAME_COLOR[1], FRAME_COLOR[2], arrow.opacity);
                    p.strokeWeight(2);
                    p.line(arrow.startX, arrow.startY, endX, endY);
                    
                    if (arrow.progress > 0.1) {
                        const headLength = 10;
                        const headAngle = 0.3;
                        
                        const headX1 = endX - headLength * Math.cos(arrow.angle - headAngle);
                        const headY1 = endY - headLength * Math.sin(arrow.angle - headAngle);
                        const headX2 = endX - headLength * Math.cos(arrow.angle + headAngle);
                        const headY2 = endY - headLength * Math.sin(arrow.angle + headAngle);
                        
                        p.line(endX, endY, headX1, headY1);
                        p.line(endX, endY, headX2, headY2);
                    }
                    
                    if (arrow.progress >= 1) {
                        redirectArrows.splice(i, 1);
                    }
                }
            }
            
            function addQuestionMark() {
                const isInCircle = p.random() > 0.5;
                const radius = p.random(p.width * 0.2, p.width * 0.45);
                const angle = p.random(p.TWO_PI);
                
                let x, y;
                if (isInCircle) {
                    x = p.width/2 + radius * Math.cos(angle);
                    y = p.height/2 + radius * Math.sin(angle);
                } else {
                    x = p.random(p.width * 0.1, p.width * 0.9);
                    y = p.random(p.height * 0.1, p.height * 0.9);
                }
                
                questionMarks.push({
                    x: x,
                    y: y,
                    size: p.random(15, 45),
                    opacity: p.random(30, 150),
                    angle: p.random(-0.2, 0.2),
                    driftX: p.random(-0.2, 0.2),
                    driftY: p.random(-0.3, 0.1),
                    pulseSpeed: p.random(0.02, 0.05),
                    lifetime: 0,
                    maxLifetime: p.random(400, 800)
                });
            }
            
            function updateAndDrawQuestionMarks() {
                for (let i = questionMarks.length - 1; i >= 0; i--) {
                    const qm = questionMarks[i];
                    
                    qm.lifetime++;
                    qm.x += qm.driftX;
                    qm.y += qm.driftY;
                    
                    const pulseSize = qm.size * (0.8 + 0.2 * Math.sin(qm.lifetime * qm.pulseSpeed));
                    const fadeOpacity = qm.lifetime > qm.maxLifetime * 0.7 
                        ? p.map(qm.lifetime, qm.maxLifetime * 0.7, qm.maxLifetime, qm.opacity, 0) 
                        : qm.opacity;
                    
                    p.fill(QUESTION_COLOR[0], QUESTION_COLOR[1], QUESTION_COLOR[2], fadeOpacity);
                    p.noStroke();
                    p.push();
                    p.translate(qm.x, qm.y);
                    p.rotate(qm.angle);
                    p.textSize(pulseSize);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.text("?", 0, 0);
                    p.pop();
                    
                    if (qm.lifetime >= qm.maxLifetime || 
                        qm.x < -50 || qm.x > p.width + 50 || 
                        qm.y < -50 || qm.y > p.height + 50) {
                        questionMarks.splice(i, 1);
                        
                        if (questionMarks.length < 12) {
                            addQuestionMark();
                        }
                    }
                }
            }
            
            function addEchoText(x, y) {
                const response = elizaResponses[Math.floor(p.random(elizaResponses.length))];
                
                echoText.push({
                    text: response,
                    x: x,
                    y: y,
                    targetY: y - p.random(30, 80),
                    opacity: 255,
                    size: 16,
                    lifetime: 0,
                    maxLifetime: p.random(120, 200),
                    fadeStart: 60
                });
            }
            
            function updateAndDrawEchoText() {
                for (let i = echoText.length - 1; i >= 0; i--) {
                    const text = echoText[i];
                    
                    text.lifetime++;
                    text.y = p.lerp(text.y, text.targetY, 0.03);
                    
                    if (text.lifetime > text.fadeStart) {
                        text.opacity = p.map(
                            text.lifetime, 
                            text.fadeStart, 
                            text.maxLifetime, 
                            255, 0
                        );
                    }
                    
                    p.fill(100, 100, 100, text.opacity);
                    p.noStroke();
                    p.textSize(12);
                    p.textAlign(p.CENTER);
                    p.text(text.text, text.x, text.y);
                    
                    if (text.lifetime >= text.maxLifetime) {
                        echoText.splice(i, 1);
                    }
                }
            }
            
            p.mousePressed = function() {
                if (isMouseInCanvas()) {
                    addReflectionPoint(p.mouseX, p.mouseY);
                    return false;
                }
            };
            
            p.mouseDragged = function() {
                if (isMouseInCanvas() && p.frameCount % 20 === 0) {
                    addReflectionPoint(p.mouseX, p.mouseY);
                }
                return false;
            };
            
            p.doubleClicked = function() {
                if (isMouseInCanvas()) {
                    reflectionPoints = [];
                    redirectArrows = [];
                    questionMarks = [];
                    echoText = [];
                    
                    for (let i = 0; i < 8; i++) {
                        addQuestionMark();
                    }
                    
                    return false;
                }
            };
            
            function isMouseInCanvas() {
                return p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height;
            }
            
            p.windowResized = function() {
                let container = document.getElementById('visualization-container');
                p.resizeCanvas(container.offsetWidth, container.offsetHeight);
                
                mirrorFrame = {
                    ...mirrorFrame,
                    x: p.width * 0.5,
                    y: p.height * 0.5,
                    width: p.width * 0.7,
                    height: p.height * 0.7
                };
            };
        };
        
        // Start the P5 sketch
        new p5(elizaSketch, 'visualization-container');
    </script>
</body>
</html>