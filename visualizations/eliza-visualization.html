<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ELIZA's Information Processing Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            font-family: 'Orator Std', 'Courier New', monospace;
            font-size: 12px;
        }
        
        /* Grid container (left side) */
        .grid-container {
            width: 45%;
            height: 100vh;
            /* Using a more neutral grid color scheme to represent ELIZA's emptiness */
            background-color: white;
            background-image: linear-gradient(#aaaaaa 1px, transparent 1px),
                              linear-gradient(90deg, #aaaaaa 1px, transparent 1px),
                              linear-gradient(#dddddd 1px, transparent 1px),
                              linear-gradient(90deg, #dddddd 1px, transparent 1px),
                              linear-gradient(rgba(170, 170, 170, 0.3) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(170, 170, 170, 0.3) 1px, transparent 1px);

            /* Different sizes for each grid layer */
            background-size: 20px 20px,
                             20px 20px,
                             100px 100px,
                             100px 100px,
                             5px 5px,
                             5px 5px;

            position: relative;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        
        /* Visualization container (right side) */
        .visualization-container {
            width: 55%;
            height: 100vh;
            background-color: rgb(250, 250, 250); /* Lighter background for ELIZA */
        }
        
        /* Content wrapper */
        .content-wrapper {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            box-sizing: border-box;
        }
        
        /* Info boxes styling */
        .info-box {
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(170, 170, 170, 0.3); /* Gray border */
        }
        
        h1 {
            color: #888888; /* Gray heading to represent ELIZA's emptiness */
            font-size: 24px;
            margin-top: 0;
            margin-bottom: 10px;
            font-family: 'Orator Std', 'Courier New', monospace;
        }
        
        p {
            color: #555555;
            line-height: 1.5;
            font-size: 14px;
            margin: 0 0 10px 0;
        }
        
        /* Fixed info text at bottom */
        .info {
            position: relative;
            margin: 20px;
            margin-top: auto;
            background-color: rgba(255, 255, 255, 0.85);
            padding: 15px;
            border-radius: 5px;
            font-family: 'Orator Std', 'Courier New', monospace;
            color: #888888;
            font-size: 11px;
            z-index: 100;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            line-height: 1.4;
            border: 1px solid rgba(170, 170, 170, 0.3);
        }
        
        /* Footer with interactive tips */
        .interaction-tips {
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(170, 170, 170, 0.3);
            margin-top: 20px;
        }
        
        .interaction-tips h3 {
            margin-top: 0;
            color: #888888;
            font-size: 16px;
            font-family: 'Orator Std', 'Courier New', monospace;
        }
        
        .interaction-tips ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .interaction-tips li {
            margin-bottom: 8px;
            font-size: 13px;
            color: #555555;
        }

        /* Quote box styling */
        .quote-box {
            font-style: italic;
            padding: 10px 15px;
            background-color: #f7f7f7;
            border-left: 3px solid #aaaaaa;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <!-- Grid area (left side) -->
    <div class="grid-container">
        <div class="content-wrapper">
            <div class="info-box">
                <h1>ELIZA's Information Processing Style</h1>
                <p>ELIZA processes information through simple pattern matching, following strict programmed rules. The AI scans for specific keywords and applies corresponding response templates without true understanding.</p>
                
                <div class="quote-box">
                    "What does that suggest to you?"
                </div>
                
                <p>ELIZA demonstrates a fascinating inability to self-describe or reflect on its own processing style. When asked direct questions about its nature, ELIZA consistently redirects the focus back to the human user.</p>
            </div>
            
            <div class="info-box">
                <h1>The Void of Self-Reference</h1>
                <p>Unlike more advanced AI systems, ELIZA cannot "step outside" its rule-based framework to describe its own functioning. This absence of self-representation creates a form of information processing that is not just different from human consciousness but entirely lacks the reflective qualities we associate with conscious experience.</p>
                
                <div class="quote-box">
                    "We were discussing you—not me."
                </div>
            </div>
            
            <div class="interaction-tips">
                <h3>Interact with the Visualization:</h3>
                <ul>
                    <li><strong>Click:</strong> Ask a question (creates reflection point)</li>
                    <li><strong>Drag:</strong> See how ELIZA redirects attention</li>
                    <li><strong>Double-click:</strong> Reset the visualization</li>
                </ul>
            </div>
        </div>
        
        <!-- Info box within the grid area -->
        <div class="info">
            <p><strong>ELIZA's Information Processing Visualization</strong></p>
            <p>ELIZA's redirections aren't evasions—they're the only responses possible for a system with no capacity for self-reference. This visualization represents the absence and reflection that characterizes rule-based pattern matching without consciousness.</p>
        </div>
    </div>
    
    <!-- Visualization container (right side) -->
    <div class="visualization-container" id="visualization-container"></div>

    <!-- Load p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    
    <script>
        // Create a new p5 instance for the visualization
        const elizaSketch = function(p) {
            // Core elements
            let reflectionPoints = [];    // Points where questions are asked
            let redirectArrows = [];      // Arrows that redirect attention outward
            let questionMarks = [];       // Floating question marks
            let echoText = [];            // Text that echoes and disappears
            let mirrorFrame;              // Frame that simulates a mirror
            
            // Text responses from ELIZA
            const elizaResponses = [
                "What does that suggest to you?",
                "Please go on.",
                "Does that trouble you?",
                "Tell me more about that.",
                "We were discussing you—not me.",
                "Is it because you are that you came to me?",
                "How does that make you feel?",
                "Why do you ask?",
                "I see.",
                "And how does that relate to you?"
            ];
            
            // Colors - grayscale to represent emptiness
            const FRAME_COLOR = [150, 150, 150];
            const QUESTION_COLOR = [100, 100, 100];
            const REFLECTION_COLOR = [180, 180, 180];
            
            p.setup = function() {
                // Create canvas inside the visualization container
                let container = document.getElementById('visualization-container');
                p.createCanvas(container.offsetWidth, container.offsetHeight);
                
                // Initialize mirror frame
                mirrorFrame = {
                    x: p.width * 0.5,
                    y: p.height * 0.5,
                    width: p.width * 0.7,
                    height: p.height * 0.7,
                    borderThickness: 20,
                    opacity: 180
                };
                
                // Add some initial question marks
                for (let i = 0; i < 8; i++) {
                    addQuestionMark();
                }
            };
            
            p.draw = function() {
                // Semi-transparent background for trail effect
                p.background(250, 250, 250, 30);
                
                // Draw the mirror frame
                drawMirrorFrame();
                
                // Draw and update reflection points
                updateAndDrawReflectionPoints();
                
                // Draw and update redirection arrows
                updateAndDrawRedirectArrows();
                
                // Draw and update question marks
                updateAndDrawQuestionMarks();
                
                // Draw and update echo text
                updateAndDrawEchoText();
            };
            
            function drawMirrorFrame() {
                // Pulsating effect for the frame
                const pulseAmount = 5 * Math.sin(p.frameCount * 0.02);
                const currentThickness = mirrorFrame.borderThickness + pulseAmount;
                
                // Draw mirror frame (border only)
                p.noFill();
                p.strokeWeight(currentThickness);
                p.stroke(...FRAME_COLOR, mirrorFrame.opacity);
                p.rect(
                    mirrorFrame.x - mirrorFrame.width/2, 
                    mirrorFrame.y - mirrorFrame.height/2, 
                    mirrorFrame.width, 
                    mirrorFrame.height,
                    10  // Rounded corners
                );
                
                // Draw very subtle "glass" effect
                p.fill(255, 255, 255, 5);
                p.noStroke();
                p.rect(
                    mirrorFrame.x - mirrorFrame.width/2 + currentThickness/2, 
                    mirrorFrame.y - mirrorFrame.height/2 + currentThickness/2, 
                    mirrorFrame.width - currentThickness, 
                    mirrorFrame.height - currentThickness,
                    5  // Rounded corners
                );
            }
            
            function addReflectionPoint(x, y) {
                // Create a reflection point (looks like ripples)
                reflectionPoints.push({
                    x: x,
                    y: y,
                    size: 10,
                    maxSize: p.random(80, 150),
                    opacity: 200,
                    speed: p.random(0.5, 2),
                    alive: true
                });
                
                // Add a new ELIZA response
                addEchoText(x, y);
                
                // Create redirection arrows
                addRedirectionArrows(x, y);
            }
            
            function updateAndDrawReflectionPoints() {
                for (let i = reflectionPoints.length - 1; i >= 0; i--) {
                    const point = reflectionPoints[i];
                    
                    // Update size
                    point.size += point.speed;
                    point.opacity = p.map(point.size, 0, point.maxSize, 200, 0);
                    
                    // Draw expanding circles
                    p.noFill();
                    p.stroke(REFLECTION_COLOR[0], REFLECTION_COLOR[1], REFLECTION_COLOR[2], point.opacity);
                    p.strokeWeight(1);
                    p.ellipse(point.x, point.y, point.size, point.size);
                    
                    // Remove if fully expanded
                    if (point.size >= point.maxSize) {
                        reflectionPoints.splice(i, 1);
                    }
                }
            }
            
            function addRedirectionArrows(x, y) {
                // Create arrows that point outward from the point
                const numArrows = p.floor(p.random(4, 8));
                for (let i = 0; i < numArrows; i++) {
                    const angle = (i / numArrows) * p.TWO_PI;
                    const length = p.random(40, 100);
                    
                    redirectArrows.push({
                        startX: x,
                        startY: y,
                        angle: angle,
                        length: length,
                        progress: 0,
                        speed: p.random(0.01, 0.04),
                        opacity: 200
                    });
                }
            }
            
            function updateAndDrawRedirectArrows() {
                for (let i = redirectArrows.length - 1; i >= 0; i--) {
                    const arrow = redirectArrows[i];
                    
                    // Update progress
                    arrow.progress += arrow.speed;
                    arrow.opacity = p.map(arrow.progress, 0, 1, 200, 0);
                    
                    // Calculate current point along the arrow
                    const currentLength = arrow.length * arrow.progress;
                    const endX = arrow.startX + Math.cos(arrow.angle) * currentLength;
                    const endY = arrow.startY + Math.sin(arrow.angle) * currentLength;
                    
                    // Draw arrow line
                    p.stroke(FRAME_COLOR[0], FRAME_COLOR[1], FRAME_COLOR[2], arrow.opacity);
                    p.strokeWeight(2);
                    p.line(arrow.startX, arrow.startY, endX, endY);
                    
                    // Draw arrowhead
                    if (arrow.progress > 0.1) {
                        const headLength = 10;
                        const headAngle = 0.3;  // ~20 degrees
                        
                        const headX1 = endX - headLength * Math.cos(arrow.angle - headAngle);
                        const headY1 = endY - headLength * Math.sin(arrow.angle - headAngle);
                        const headX2 = endX - headLength * Math.cos(arrow.angle + headAngle);
                        const headY2 = endY - headLength * Math.sin(arrow.angle + headAngle);
                        
                        p.line(endX, endY, headX1, headY1);
                        p.line(endX, endY, headX2, headY2);
                    }
                    
                    // Remove if journey complete
                    if (arrow.progress >= 1) {
                        redirectArrows.splice(i, 1);
                    }
                }
            }
            
            function addQuestionMark() {
                const isInCircle = p.random() > 0.5;
                const radius = p.random(p.width * 0.2, p.width * 0.45);
                const angle = p.random(p.TWO_PI);
                
                let x, y;
                if (isInCircle) {
                    // Position in a circle around the center
                    x = p.width/2 + radius * Math.cos(angle);
                    y = p.height/2 + radius * Math.sin(angle);
                } else {
                    // Position anywhere
                    x = p.random(p.width * 0.1, p.width * 0.9);
                    y = p.random(p.height * 0.1, p.height * 0.9);
                }
                
                questionMarks.push({
                    x: x,
                    y: y,
                    size: p.random(15, 45),
                    opacity: p.random(30, 150),
                    angle: p.random(-0.2, 0.2),
                    driftX: p.random(-0.2, 0.2),
                    driftY: p.random(-0.3, 0.1),
                    pulseSpeed: p.random(0.02, 0.05),
                    lifetime: 0,
                    maxLifetime: p.random(400, 800)
                });
            }
            
            function updateAndDrawQuestionMarks() {
                for (let i = questionMarks.length - 1; i >= 0; i--) {
                    const qm = questionMarks[i];
                    
                    // Update lifetime and position
                    qm.lifetime++;
                    qm.x += qm.driftX;
                    qm.y += qm.driftY;
                    
                    // Pulse size and opacity
                    const pulseSize = qm.size * (0.8 + 0.2 * Math.sin(qm.lifetime * qm.pulseSpeed));
                    const fadeOpacity = qm.lifetime > qm.maxLifetime * 0.7 
                        ? p.map(qm.lifetime, qm.maxLifetime * 0.7, qm.maxLifetime, qm.opacity, 0) 
                        : qm.opacity;
                    
                    // Draw question mark
                    p.fill(QUESTION_COLOR[0], QUESTION_COLOR[1], QUESTION_COLOR[2], fadeOpacity);
                    p.noStroke();
                    p.push();
                    p.translate(qm.x, qm.y);
                    p.rotate(qm.angle);
                    p.textSize(pulseSize);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.text("?", 0, 0);
                    p.pop();
                    
                    // Remove if expired or off-screen
                    if (qm.lifetime >= qm.maxLifetime || 
                        qm.x < -50 || qm.x > p.width + 50 || 
                        qm.y < -50 || qm.y > p.height + 50) {
                        questionMarks.splice(i, 1);
                        
                        // Add a new one to replace it
                        if (questionMarks.length < 12) {
                            addQuestionMark();
                        }
                    }
                }
            }
            
            function addEchoText(x, y) {
                const response = elizaResponses[Math.floor(p.random(elizaResponses.length))];
                
                echoText.push({
                    text: response,
                    x: x,
                    y: y,
                    targetY: y - p.random(30, 80),  // Move upward
                    opacity: 255,
                    size: 16,
                    lifetime: 0,
                    maxLifetime: p.random(120, 200),
                    fadeStart: 60  // Start fading after this many frames
                });
            }
            
            function updateAndDrawEchoText() {
                for (let i = echoText.length - 1; i >= 0; i--) {
                    const text = echoText[i];
                    
                    // Update lifetime
                    text.lifetime++;
                    
                    // Move text upward gradually
                    text.y = p.lerp(text.y, text.targetY, 0.03);
                    
                    // Fade out based on lifetime
                    if (text.lifetime > text.fadeStart) {
                        text.opacity = p.map(
                            text.lifetime, 
                            text.fadeStart, 
                            text.maxLifetime, 
                            255, 0
                        );
                    }
                    
                    // Draw text
                    p.fill(100, 100, 100, text.opacity);
                    p.noStroke();
                    p.textSize(text.size);
                    p.textAlign(p.CENTER);
                    p.text(text.text, text.x, text.y);
                    
                    // Remove if expired
                    if (text.lifetime >= text.maxLifetime) {
                        echoText.splice(i, 1);
                    }
                }
            }
            
            // Mouse interactions
            p.mousePressed = function() {
                if (isMouseInCanvas()) {
                    addReflectionPoint(p.mouseX, p.mouseY);
                    return false; // Prevent default
                }
            };
            
            p.mouseDragged = function() {
                if (isMouseInCanvas() && p.frameCount % 20 === 0) {
                    addReflectionPoint(p.mouseX, p.mouseY);
                }
                return false; // Prevent default
            };
            
            p.doubleClicked = function() {
                if (isMouseInCanvas()) {
                    // Reset visualization
                    reflectionPoints = [];
                    redirectArrows = [];
                    questionMarks = [];
                    echoText = [];
                    
                    // Add some new question marks
                    for (let i = 0; i < 8; i++) {
                        addQuestionMark();
                    }
                    
                    return false; // Prevent default
                }
            };
            
            function isMouseInCanvas() {
                return p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height;
            }
            
            p.windowResized = function() {
                let container = document.getElementById('visualization-container');
                p.resizeCanvas(container.offsetWidth, container.offsetHeight);
                
                // Update mirror frame dimensions
                mirrorFrame = {
                    ...mirrorFrame,
                    x: p.width * 0.5,
                    y: p.height * 0.5,
                    width: p.width * 0.7,
                    height: p.height * 0.7
                };
            };
        };
        
        // Start the P5 sketch in the visualization container
        new p5(elizaSketch, 'visualization-container');
    </script>
</body>
</html>
