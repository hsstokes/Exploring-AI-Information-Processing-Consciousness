<!DOCTYPE html>
<html lang="en">
<head>
    <title>Replika: Pattern Recognition</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f5f5f7;
            font-family: 'Roboto Mono', monospace;
            -webkit-text-size-adjust: 100%;
            touch-action: none;
        }
        
        /* Landing page overlay */
        #landing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(245, 245, 247, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            box-sizing: border-box;
            padding: 20px;
        }
        
        .grid-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(#8A5FC3 1px, transparent 1px),
                            linear-gradient(90deg, #8A5FC3 1px, transparent 1px),
                            linear-gradient(rgba(138, 95, 195, 0.3) 1px, transparent 1px),
                            linear-gradient(90deg, rgba(138, 95, 195, 0.3) 1px, transparent 1px);
            background-size: 20px 20px,
                            20px 20px,
                            5px 5px,
                            5px 5px;
            z-index: -1;
        }
        
        .content {
            max-width: 500px;
            padding: 25px;
            background-color: rgba(255, 255, 255, 0.85);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            text-align: center;
        }
        
        .title {
            font-size: 18px;
            margin: 0 0 15px 0;
            color: #333;
            letter-spacing: 1px;
        }
        
        .description {
            font-size: 13px;
            line-height: 1.4;
            margin-bottom: 20px;
            color: #555;
        }
        
        .button {
            padding: 12px 24px;
            font-size: 16px;
            background-color: #8A5FC3;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Roboto Mono', monospace;
            transition: all 0.3s ease;
            letter-spacing: 0.5px;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
            touch-action: manipulation;
            margin: 15px 0 5px 0;
            display: inline-block;
            text-decoration: none;
        }
        
        .button:hover {
            background-color: #7952B3;
            transform: translateY(-2px);
        }
        
        .button:active {
            transform: scale(0.98);
        }
        
        .gesture-container {
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
        }
        
        .gesture-outline {
            width: 80px;
            height: 80px;
            border: 2px solid #8A5FC3;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0.8;
        }
        
        /* Main visualization styles */
        #camera-feed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            display: none; /* Hidden by default */
        }
        
        /* Solid background element */
        #solid-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #f0f0f5;
            z-index: 1;
            display: block; /* Shown by default */
        }
        
        #visualization-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: auto;
            display: none; /* Hidden until landing page dismissed */
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            font-family: 'Roboto Mono', monospace;
            display: none; /* Hidden until landing page dismissed */
            background-image: linear-gradient(rgba(138, 95, 195, 0.1) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(138, 95, 195, 0.1) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        .sound-note {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            background-color: rgba(138, 95, 195, 0.8);
            padding: 10px 20px;
            border-radius: 30px;
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            z-index: 4;
            opacity: 1;
            transition: opacity 2s ease-in-out;
            display: none; /* Hidden until landing page dismissed */
        }
        
        .sound-note.fade {
            opacity: 0;
        }
        
        /* Tutorial overlay */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0);
            display: flex;
            justify-content: center;
            align-items: flex-end;
            z-index: 9000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            padding-bottom: 80px;
        }
        
        .tutorial-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .tutorial-hint {
            background-color: rgba(138, 95, 195, 0.9);
            padding: 12px 20px;
            border-radius: 30px;
            max-width: 85%;
            text-align: center;
            margin-bottom: 0;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            animation: pulse 2s infinite;
         }

         @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
         }

         .tutorial-hint p {
            margin: 0;
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
         }

        /* Touch indicator */
        .touch-indicator {
            position: fixed;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(138, 95, 195, 0.6);
            pointer-events: none;
            z-index: 10;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Touch indicator -->
    <div id="touch-indicator" class="touch-indicator"></div>
    
    <!-- Tutorial overlay that serves as the main UI control -->
    <div id="tutorial-overlay" class="tutorial-overlay">
        <div id="tutorial-hint" class="tutorial-hint">
            <p id="tutorial-text">Tap anywhere to start</p>
        </div>
    </div>
    
    <!-- Landing page -->
    <div id="landing-overlay">
        <div class="grid-background"></div>
        
        <div class="content">
            <div class="gesture-container">
                <div class="gesture-outline">
                    <svg width="50" height="50" viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
                        <!-- Replika emotional pattern recognition icon -->
                        <circle cx="25" cy="25" r="15" fill="#8A5FC3" opacity="0.7" />
                        <!-- Add connecting nodes to represent relationship building -->
                        <circle cx="18" cy="15" r="4" fill="#A978DE" />
                        <circle cx="32" cy="15" r="4" fill="#A978DE" />
                        <circle cx="36" cy="28" r="4" fill="#A978DE" />
                        <circle cx="14" cy="28" r="4" fill="#A978DE" />
                        <!-- Connection lines -->
                        <line x1="18" y1="15" x2="25" y2="25" stroke="#A978DE" stroke-width="2" />
                        <line x1="32" y1="15" x2="25" y2="25" stroke="#A978DE" stroke-width="2" />
                        <line x1="36" y1="28" x2="25" y2="25" stroke="#A978DE" stroke-width="2" />
                        <line x1="14" y1="28" x2="25" y2="25" stroke="#A978DE" stroke-width="2" />
                    </svg>
                </div>
            </div>
            
            <div class="title">Replika: Pattern Recognition</div>
            
            <div class="description">
                Experience how Replika processes emotional patterns and forms connections. This visualization reveals the unique architecture of an AI system designed to recognize emotional nuances and adapt to your personal communication style. Watch as Replika's neural patterns shift and respond to create more meaningful, empathetic interactions.
            </div>
            
            <div class="description">
                <em>Tap the button below to explore the visualization.</em>
            </div>
            
            <button id="start-button" class="button">BEGIN INTERACTION</button>
        </div>
    </div>
    
    <!-- Loading screen -->
    <div class="loading" id="loading">
        <div>
            <h2>Loading...</h2>
            <p>Preparing visualization</p>
        </div>
    </div>
    
    <!-- Sound note that fades away -->
    <div class="sound-note" id="sound-note">Sound available with headphones</div>
    
    <!-- Camera background (hidden by default) -->
    <video id="camera-feed" autoplay playsinline></video>
    
    <!-- Solid background (shown by default) -->
    <div id="solid-background"></div>
    
    <!-- p5.js visualization will be attached to this div -->
    <div id="visualization-overlay"></div>
    
    <script>
        // Global reference to p5 instance
        let p5Instance = null;
        
        // Tutorial state
        let tutorialStep = 0;
        let tutorialShown = false;
        const tutorialSteps = [
            "Tap anywhere to start",
            "Continue moving to create connections",
            "Tap to create new nodes"
        ];
        
        // Touch tracking
        let lastTouchPosition = {x: 0, y: 0, active: false, timer: 0};
        const touchIndicator = document.getElementById('touch-indicator');
        
        // Hand animation configuration
        const handAnimation = {
            frameCount: 6,
            currentFrame: 0,
            frameDuration: 100,
            opacity: 0.85,
            x: 0,
            y: 0,
            size: 250,
            frameImages: [],
            isPlaying: true, // Always playing
            rotationOffset: 0, // Add gentle rotation
            rotationSpeed: 0.001, // Very slow rotation
            lastFrameTime: 0 // For timing frames
        };
        
        // Function for continuous hand animation (defined globally)
        function updateHandAnimationContinuous() {
            const now = Date.now();
            const elapsed = now - handAnimation.lastFrameTime;
            
            if (elapsed > handAnimation.frameDuration) {
                handAnimation.currentFrame = (handAnimation.currentFrame + 1) % handAnimation.frameCount;
                handAnimation.lastFrameTime = now;
                
                // Update rotation for gentle movement
                handAnimation.rotationOffset += handAnimation.rotationSpeed;
            }
            
            // Always request next frame
            requestAnimationFrame(updateHandAnimationContinuous);
        }
        
        // Start the entire experience
        document.addEventListener('DOMContentLoaded', function() {
            // Set up the landing page button
            document.getElementById('start-button').addEventListener('click', startExperience);
            document.getElementById('start-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                startExperience();
            });
            
            // Set up tutorial handler
            document.getElementById('tutorial-hint').addEventListener('click', advanceTutorial);
            document.getElementById('tutorial-hint').addEventListener('touchend', function(e) {
                e.preventDefault();
                advanceTutorial();
            });
            
            // Disable default touch behaviors on the document
            document.addEventListener('touchmove', function(e) {
                if (!e.target.closest('button')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            document.addEventListener('touchstart', function(e) {
                if (!e.target.closest('button')) {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Preload p5 assets in the background
            new p5(replikaSketch, 'visualization-overlay');
        });
        
        // Show touch indicator at the specified position
        function showTouchIndicator(x, y) {
            touchIndicator.style.left = x + 'px';
            touchIndicator.style.top = y + 'px';
            touchIndicator.style.opacity = '1';
            
            // Hide indicator after a short delay
            setTimeout(() => {
                touchIndicator.style.opacity = '0';
            }, 300);
        }
        
        function startExperience() {
            // Hide landing page
            document.getElementById('landing-overlay').style.display = 'none';
            
            // Show main interface elements
            document.getElementById('loading').style.display = 'flex';
            document.getElementById('visualization-overlay').style.display = 'block';
            document.getElementById('sound-note').style.display = 'block';
            
            // Hide loading after a short delay
            setTimeout(function() {
                document.getElementById('loading').style.display = 'none';
            }, 1500);
            
            // Fade out sound note after 5 seconds
            setTimeout(function() {
                document.getElementById('sound-note').classList.add('fade');
            }, 5000);
            
            // Show tutorial after a short delay
            setTimeout(function() {
                if (!tutorialShown) {
                    showTutorial();
                }
            }, 2000);
        }
        
        function showTutorial() {
            tutorialStep = 0;
            document.getElementById('tutorial-text').textContent = tutorialSteps[tutorialStep];
            document.getElementById('tutorial-overlay').classList.add('active');
            tutorialShown = true;
            console.log("Tutorial shown: Step " + tutorialStep);
         }
        
        function advanceTutorial() {
            console.log("Advancing tutorial from step " + tutorialStep);
            
            tutorialStep++;
            if (tutorialStep < tutorialSteps.length) {
                document.getElementById('tutorial-text').textContent = tutorialSteps[tutorialStep];
                console.log("Advanced to step " + tutorialStep + ": " + tutorialSteps[tutorialStep]);
            } else {
                document.getElementById('tutorial-overlay').classList.remove('active');
                console.log("Tutorial completed and hidden");
            }
        }
        
        // Create a new p5 instance for the visualization overlay
        const replikaSketch = function(p) {
            // Store a reference to p5 instance
            p5Instance = p;
            
            let spheres = [];
            const NUM_SPHERES = 25;
            const MIN_SPHERES = 15;
            let lastFrameCount = 0;
            p.interactionSound = null;
            let lastInteractionTime = 0;
            
            // Color palettes
            const coolColors = [
              [41, 171, 226],    // Blue
              [0, 169, 157],     // Teal
              [0, 133, 161],     // Deep blue-green
              [76, 195, 172]     // Mint
            ];
            
            const warmColors = [
              [253, 198, 137],   // Peach
              [241, 142, 109],   // Coral
              [227, 115, 131],   // Warm pink
              [253, 175, 122]    // Light orange
            ];
            
            p.preload = function() {
                console.log("Starting to load hand animation frames...");
                
                // Preload hand animation frames
                handAnimation.frameImages = [];
                for (let i = 1; i <= handAnimation.frameCount; i++) {
                    console.log(`Attempting to load hand${i}.png`);
                    try {
                        const img = p.loadImage(
                            `hand${i}.png`,
                            function() {
                                console.log(`Successfully loaded hand${i}.png`);
                            },
                            function(err) {
                                console.error(`Failed to load hand${i}.png:`, err);
                                // Create a placeholder image for debugging
                                const placeholder = p.createGraphics(200, 200);
                                placeholder.background(255, 0, 0, 100);
                                placeholder.fill(255);
                                placeholder.textSize(24);
                                placeholder.textAlign(p.CENTER, p.CENTER);
                                placeholder.text(`Hand ${i}`, 100, 100);
                                handAnimation.frameImages[i-1] = placeholder;
                            }
                        );
                        handAnimation.frameImages.push(img);
                    } catch (e) {
                        console.error("Error loading image:", e);
                    }
                }
                
                try {
                    console.log("Loading sound...");
                    p.soundFormats('wav');
                    
                    p.interactionSound = p.loadSound('balanced-sound.wav',  
                        function() {
                            console.log("Sound loaded successfully!");
                        },
                        function(err) {
                            console.error("Sound loading error:", err);
                        }
                    );
                } catch (e) {
                    console.error('Sound loading exception:', e);
                    p.interactionSound = null;
                }
            };
            
            p.setup = function() {
                // Create canvas inside the visualization overlay
                let canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('visualization-overlay');

                // Position hand animation at center of canvas
                handAnimation.x = p.width / 2;
                handAnimation.y = p.height / 2;
                handAnimation.lastFrameTime = Date.now();
    
                // Start continuous animation immediately
                requestAnimationFrame(updateHandAnimationContinuous);
                
                // Create initial spheres
                for (let i = 0; i < NUM_SPHERES; i++) {
                    createSphere();
                }
                
                // Initialize connections
                updateConnections();
                
                // Auto-initialize audio
                p.userStartAudio();
                
                // Special handling for iOS devices
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                if (isIOS) {
                    console.log("iOS device detected - using special audio handling");
                    document.addEventListener('touchstart', function() {
                        if (p.getAudioContext().state !== 'running') {
                            p.getAudioContext().resume();
                        }
                    }, false);
                }
                
                // Log mobile detection
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                console.log("Mobile device detected:", isMobile);
                if (isMobile) {
                    console.log("Setting up for mobile display");
                    // Adjust hand animation for mobile
                    handAnimation.size = 300; // Larger size for mobile
                }
                
                // Hide loading screen once setup is complete
                document.getElementById('loading').style.display = 'none';
            };

            
            // Function to start hand animation at specific coordinates
            function playHandAnimation(x, y) {
                console.log("Note: Hand animation is now continuous and centered. This function is deprecated.");
                
                // No longer need to check if animation is playing since it's always playing
                
                // We can still allow sphere interactions with the current hand position
                for (let i = 0; i < spheres.length; i++) {
                    const d = p.dist(handAnimation.x, handAnimation.y, spheres[i].x, spheres[i].y);
                    if (d < handAnimation.size * 0.6) {
                        // Gently push spheres toward the hand center
                        const angle = p.atan2(spheres[i].y - handAnimation.y, spheres[i].x - handAnimation.x);
                        const force = p.map(d, 0, handAnimation.size * 0.6, 0.5, 0.1);
    
                        // Add a subtle movement effect
                        spheres[i].speedX += p.cos(angle) * force * -0.5; // Pull toward hand
                        spheres[i].speedY += p.sin(angle) * force * -0.5;
                        spheres[i].pulseRate *= 1.05; // Make them pulse a bit faster
                    }
                }
                
                // Make sure nearby bubbles respond to the hand position
                for (let i = 0; i < spheres.length; i++) {
                    const d = p.dist(x, y, spheres[i].x, spheres[i].y);
                    if (d < handAnimation.size * 0.6) {
                       // Gently push spheres toward the hand center
                       const angle = p.atan2(spheres[i].y - y, spheres[i].x - x);
                       const force = p.map(d, 0, handAnimation.size * 0.6, 0.5, 0.1);
            
                       // Add a subtle movement effect
                       spheres[i].speedX += p.cos(angle) * force * -0.5; // Pull toward hand
                       spheres[i].speedY += p.sin(angle) * force * -0.5;
                       spheres[i].pulseRate *= 1.05; // Make them pulse a bit faster
                    }
                }
            }
            
            // Draw the current animation frame
            function drawHandAnimationFrame() {
                const anim = handAnimation;
                
                if (anim.frameImages[anim.currentFrame]) {
                    // First draw a visual indicator/background to make it more visible
                    p.push();
                    p.noStroke();

                    // Create a blurred background using multiple overlapping circles with decreasing opacity
                    for (let i = 0; i < 3; i++) {
                        const blurOpacity = anim.opacity * (80 - i * 20);
                        const blurSize = anim.size * (1.05 + i * 0.04);
                        p.fill(255, 255, 255, blurOpacity);
                        p.ellipse(anim.x, anim.y, blurSize);
                    }
                    p.pop();
                    
                    // Save current drawing settings
                    p.push();
                    
                    // Apply rotation for gentle movement
                    p.translate(anim.x, anim.y);
                    p.rotate(anim.rotationOffset);
                    p.translate(-anim.x, -anim.y);
                    
                    // Set transparency
                    p.tint(0, 0, 0, Math.min(255, anim.opacity * 950));

                    // Add a stronger glow effect
                    p.drawingContext.shadowColor = 'rgba(0, 0, 0, 0.9)';
                    p.drawingContext.shadowBlur = 40;
                    p.drawingContext.shadowOffsetX = 0;
                    p.drawingContext.shadowOffsetY = 0;
        
                    // Get the current frame image
                    const img = anim.frameImages[anim.currentFrame];
        
                    // Calculate height while preserving aspect ratio
                    const aspectRatio = img.height / img.width;
                    const drawHeight = anim.size * aspectRatio;
                    
                    // Draw the current frame centered at x,y 
                    p.image(
                        img,
                        anim.x - anim.size/2,
                        anim.y - drawHeight/2, // Correct vertical centering
                        anim.size,
                        drawHeight
                    );

                    // Draw a second time with different color to create contrast
                    p.tint(255, 255, 255, Math.min(255, anim.opacity * 400));
                    p.drawingContext.shadowColor = 'rgba(255, 255, 255, 0.7)';
                    p.drawingContext.shadowBlur = 4;
        
                    p.image(
                        img,
                        anim.x - anim.size/2,
                        anim.y - drawHeight/2,
                        anim.size,
                        drawHeight
                    );
                    
                    // Restore drawing settings
                    p.pop();
                } else {
                    console.error(`Image for frame ${anim.currentFrame} not found!`);
                    
                    // Draw a simple circle as fallback
                    p.push();
                    p.noStroke();
                    p.fill(0, 0, 0, anim.opacity * 255);
                    p.ellipse(anim.x, anim.y, anim.size * 0.5);
                    p.pop();
                }
            }
            
            // Function to update connections safely
            function updateConnections() {
                try {
                    // Clear all connections first
                    for (let i = 0; i < spheres.length; i++) {
                        spheres[i].connections = [];
                    }
                    
                    // Add new connections
                    for (let i = 0; i < spheres.length; i++) {
                        // Each sphere connects to 2-5 others
                        const numConnections = p.floor(p.random(2, 6));
                        const availableSpheres = [];
                        
                        // Create list of available spheres to connect to
                        for (let j = 0; j < spheres.length; j++) {
                            if (j !== i) {
                                availableSpheres.push(j);
                            }
                        }
                        
                        // Shuffle available spheres
                        for (let j = availableSpheres.length - 1; j > 0; j--) {
                            const k = Math.floor(p.random(j + 1));
                            [availableSpheres[j], availableSpheres[k]] = [availableSpheres[k], availableSpheres[j]];
                        }
                        
                        // Add connections
                        for (let j = 0; j < Math.min(numConnections, availableSpheres.length); j++) {
                            spheres[i].connections.push(availableSpheres[j]);
                        }
                    }
                } catch (error) {
                    console.error("Error updating connections:", error);
                }
            }
            
            // Draw interactive highlight effect around spheres within interaction range
            function drawInteractionHighlights(x, y) {
                p.push();
                p.noFill();
                
                for (let i = 0; i < spheres.length; i++) {
                    const d = p.dist(x, y, spheres[i].x, spheres[i].y);
                    
                    // Only highlight spheres within interaction range
                    if (d < 200) {
                        const sphere = spheres[i];
                        const highlightSize = sphere.size * 1.5;
                        const opacity = p.map(d, 0, 200, 100, 20);
                        
                        p.stroke(138, 95, 195, opacity);
                        p.strokeWeight(2);
                        p.ellipse(sphere.x, sphere.y, highlightSize, highlightSize);
                    }
                }
                
                p.pop();
            }
            
            p.draw = function() {
                // Detect potential freezes and reset if needed
                if (p.frameCount === lastFrameCount) {
                    // Frame hasn't advanced, might be frozen
                    resetVisualization();
                    lastFrameCount = p.frameCount;
                    return;
                }
                lastFrameCount = p.frameCount;
                
                try {
                    p.clear(); // Clear with transparency
                    
                    // Make sure we always have enough spheres
                    let spheresAdded = false;
                    while (spheres.length < MIN_SPHERES) {
                        createSphere();
                        spheresAdded = true;
                    }
                    
                    if (spheresAdded) {
                        updateConnections();
                    }
                    
                    // Draw connections first (behind spheres)
                    for (let i = 0; i < spheres.length; i++) {
                        const sphere = spheres[i];
                        
                        for (let j = 0; j < sphere.connections.length; j++) {
                            const connIndex = sphere.connections[j];
                            
                            // Safety check for valid connection index
                            if (connIndex >= 0 && connIndex < spheres.length) {
                                const otherSphere = spheres[connIndex];
                                
                                // Calculate distance for connection opacity
                                const distance = p.dist(sphere.x, sphere.y, otherSphere.x, otherSphere.y);
                                const maxDist = 200;
                                const alpha = p.map(distance, 0, maxDist, 150, 20);
                                
                                if (distance < maxDist) {
                                    // Blend the colors of connected spheres
                                    const blendedColor = p.lerpColor(
                                        p.color(sphere.color[0], sphere.color[1], sphere.color[2], alpha),
                                        p.color(otherSphere.color[0], otherSphere.color[1], otherSphere.color[2], alpha),
                                        0.5
                                    );
                                    
                                    p.stroke(blendedColor);
                                    p.strokeWeight(p.map(distance, 0, maxDist, 3, 0.5));
                                    p.line(sphere.x, sphere.y, otherSphere.x, otherSphere.y);
                                }
                            }
                        }
                    }
                    
                    // Draw interaction highlights for mouse/touch position
                    if (p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height && 
                        Date.now() - lastInteractionTime < 3000) {
                        drawInteractionHighlights(p.mouseX, p.mouseY);
                    }
                    
                    // Draw and update spheres
                    for (let i = 0; i < spheres.length; i++) {
                        updateSphere(spheres[i]);
                        drawSphere(spheres[i]);
                    }
                    
                    // Occasionally add new spheres
                    if (p.frameCount % 60 === 0 && spheres.length < 40) {
                        createSphere();
                        
                        // Periodically refresh all connections
                        if (p.frameCount % 180 === 0) {
                            updateConnections();
                        }
                    }
                    
                    // Handle old spheres
                    let spheresRemoved = false;
                    if (spheres.length > MIN_SPHERES) {
                        const oldLength = spheres.length;
                        spheres = spheres.filter(s => s.age < s.lifespan);
                        spheresRemoved = (oldLength !== spheres.length);
                    }
                    else { 
                        // Refresh the oldest spheres instead of removing them
                        spheres.forEach(s => {
                            if (s.age > s.lifespan) {
                                s.age = 0;
                                s.pulseRate = p.random(0.02, 0.04);
                                s.color = getRandomColor();
                                s.x = p.constrain(s.x + p.random(-50, 50), 0, p.width);
                                s.y = p.constrain(s.y + p.random(-50, 50), 0, p.height);
                            }
                        });
                    }
                    
                    if (spheresRemoved) {
                        updateConnections();
                    }
                    
                    // Always draw the hand animation frame (last to be on top)
                    drawHandAnimationFrame();
                    
                } catch (error) {
                    console.error("Error in draw:", error);
                    resetVisualization();
                }
            };
            
            function resetVisualization() {
                console.log("Resetting visualization");
                spheres = [];
                for (let i = 0; i < NUM_SPHERES; i++) {
                    createSphere();
                }
                updateConnections();
            }
            
            function getRandomColor() {
                const palette = p.random() < 0.6 ? coolColors : warmColors;
                const baseColor = p.random(palette);
                
                return [
                    baseColor[0] + p.random(-20, 20),
                    baseColor[1] + p.random(-20, 20),
                    baseColor[2] + p.random(-20, 20)
                ];
            }
            
            function createSphere() {
                // Add slight variation to the color
                const color = getRandomColor();
                
                spheres.push({
                    x: p.random(p.width),
                    y: p.random(p.height),
                    size: p.random(15, 60),
                    color: color,
                    speedX: p.random(-0.7, 0.7),
                    speedY: p.random(-0.7, 0.7),
                    connections: [],
                    pulseRate: p.random(0.02, 0.04),
                    pulsePhase: p.random(p.TWO_PI),
                    age: 0,
                    lifespan: p.random(300, 900),
                    adaptDirection: p.random(p.TWO_PI),
                    adaptSpeed: p.random(0.001, 0.005),
                    adaptRadius: p.random(30, 80),
                    interacting: false,
                    interactionStrength: 0
                });
            }
            
            function updateSphere(sphere) {
                // Basic movement
                sphere.x += sphere.speedX;
                sphere.y += sphere.speedY;
                
                // Gentle circular adaptation around base position
                sphere.x += p.cos(p.frameCount * sphere.adaptSpeed + sphere.adaptDirection) * 0.5;
                sphere.y += p.sin(p.frameCount * sphere.adaptSpeed + sphere.adaptDirection) * 0.5;
                
                // Bounce off edges with damping
                if (sphere.x < 0 || sphere.x > p.width) {
                    sphere.speedX *= -0.9;
                    sphere.x = p.constrain(sphere.x, 0, p.width);
                }
                
                if (sphere.y < 0 || sphere.y > p.height) {
                    sphere.speedY *= -0.9;
                    sphere.y = p.constrain(sphere.y, 0, p.height);
                }
                
                // Occasionally change direction slightly to simulate adaptation
                if (p.random() < 0.02) {
                    sphere.speedX += p.random(-0.2, 0.2);
                    sphere.speedY += p.random(-0.2, 0.2);
                    
                    // Limit maximum speed
                    const maxSpeed = 1.0;
                    const currentSpeed = p.sqrt(sphere.speedX * sphere.speedX + sphere.speedY * sphere.speedY);
                    if (currentSpeed > maxSpeed) {
                        sphere.speedX = (sphere.speedX / currentSpeed) * maxSpeed;
                        sphere.speedY = (sphere.speedY / currentSpeed) * maxSpeed;
                    }
                }
                
                // Update age
                sphere.age++;
                
                // Decrease interaction strength over time
                if (sphere.interacting) {
                    sphere.interactionStrength *= 0.95;
                    if (sphere.interactionStrength < 0.05) {
                        sphere.interacting = false;
                    }
                }
            }
            
            function drawSphere(sphere) {
                // Calculate pulse effect (size oscillation)
                const pulseEffect = p.sin(p.frameCount * sphere.pulseRate + sphere.pulsePhase);
                const displaySize = sphere.size * (1 + pulseEffect * 0.1);
                
                // Calculate alpha based on age (fade in and out)
                let alpha = 255;
                const fadeInDuration = 60;
                const fadeOutDuration = 90;
                
                if (sphere.age < fadeInDuration) {
                    alpha = p.map(sphere.age, 0, fadeInDuration, 0, 255);
                } else if (sphere.age > sphere.lifespan - fadeOutDuration) {
                    alpha = p.map(sphere.age, sphere.lifespan - fadeOutDuration, sphere.lifespan, 255, 0);
                }
                
                // Enhance appearance if interacting
                let enhancedSize = displaySize;
                let colorBoost = 0;
                
                if (sphere.interacting) {
                    enhancedSize = displaySize * (1 + sphere.interactionStrength * 0.2);
                    colorBoost = sphere.interactionStrength * 50;
                }
                
                // Draw outer glow
                p.noStroke();
                for (let i = 3; i >= 0; i--) {
                    const glowSize = enhancedSize * (1 + i * 0.4);
                    const glowAlpha = alpha * (0.1 - i * 0.02);
                    p.fill(
                        p.constrain(sphere.color[0] + colorBoost, 0, 255),
                        p.constrain(sphere.color[1] + colorBoost, 0, 255),
                        p.constrain(sphere.color[2] + colorBoost, 0, 255),
                        glowAlpha
                    );
                    p.ellipse(sphere.x, sphere.y, glowSize, glowSize);
                }
                
                // Draw the main sphere with gradient
                for (let i = 1; i >= 0; i -= 0.2) {
                    const innerSize = enhancedSize * i;
                    const adjustedAlpha = alpha * p.map(i, 0, 1, 0.4, 0.9);
                    p.fill(
                        p.constrain(sphere.color[0] + p.map(i, 0, 1, 50, 0) + colorBoost, 0, 255),
                        p.constrain(sphere.color[1] + p.map(i, 0, 1, 50, 0) + colorBoost, 0, 255),
                        p.constrain(sphere.color[2] + p.map(i, 0, 1, 50, 0) + colorBoost, 0, 255),
                        adjustedAlpha
                    );
                    p.ellipse(sphere.x, sphere.y, innerSize, innerSize);
                }
                
                // Add a subtle highlight
                p.fill(255, 255, 255, alpha * 0.6);
                p.ellipse(sphere.x - enhancedSize * 0.15, sphere.y - enhancedSize * 0.15, enhancedSize * 0.3, enhancedSize * 0.3);
            }
            
            p.windowResized = function() {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
                
                // Keep hand animation centered when window resizes
                handAnimation.x = p.width / 2;
                handAnimation.y = p.height / 2;
            };
            
            // Play sound with better mobile handling
            function tryPlaySound() {
                if (!p.interactionSound) {
                    console.log("No sound available");
                    return;
                }
                
                console.log("Trying to play sound...");
                
                // First ensure audio context is running
                if (p.getAudioContext().state !== 'running') {
                    console.log("Audio context not running, trying to start...");
                    
                    p.userStartAudio()
                    .then(() => {
                        console.log("Audio context started, now playing sound");
                        
                        if (!p.interactionSound.isPlaying()) {
                            p.interactionSound.play();
                        }
                    })
                    .catch(e => {
                        console.error("Could not start audio context:", e);
                    });
                } else {
                    // Audio context is running, play directly
                    console.log("Audio context already running, playing sound directly");
                    
                    if (!p.interactionSound.isPlaying()) {
                        p.interactionSound.play();
                    }
                }
            }
            
            p.mouseMoved = function() {
                try {
                    // Find spheres near the mouse
                    let interacted = false;
                    
                    for (let i = 0; i < spheres.length; i++) {
                        const d = p.dist(p.mouseX, p.mouseY, spheres[i].x, spheres[i].y);
                        
                        // Larger interaction radius
                        if (d < 200) {
                            const sphere = spheres[i];
                            
                            // Strength of effect based on distance
                            const strength = p.map(d, 0, 200, 0.15, 0.01);
                            
                            // Create gentle attraction
                            const angle = p.atan2(p.mouseY - sphere.y, p.mouseX - sphere.x);
                            sphere.speedX += p.cos(angle) * strength;
                            sphere.speedY += p.sin(angle) * strength;
                            
                            // For emotional effect, make nearby spheres pulse stronger
                            sphere.pulseRate *= 1.01;
                            
                            // Mark as interacting for visual enhancement
                            sphere.interacting = true;
                            sphere.interactionStrength = p.map(d, 0, 200, 1.0, 0.1);
                            
                            interacted = true;
                            lastInteractionTime = Date.now();
                        }
                    }
                    
                    if (interacted) {
                        return false; // Prevent default
                    }
                } catch (error) {
                    console.error("Error in mouseMoved:", error);
                }
            };
            
            p.mousePressed = function() {
                // First ensure audio is initialized on interaction
                p.userStartAudio();
                
                // Add interactivity when clicking
                if (p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height) {
                    // Create a ripple effect
                    for (let i = 0; i < spheres.length; i++) {
                        const d = p.dist(p.mouseX, p.mouseY, spheres[i].x, spheres[i].y);
                        if (d < 300) {
                            // Push spheres slightly away from click
                            const angle = p.atan2(spheres[i].y - p.mouseY, spheres[i].x - p.mouseX);
                            const force = p.map(d, 0, 300, 3, 0);
                            
                            spheres[i].speedX += p.cos(angle) * force;
                            spheres[i].speedY += p.sin(angle) * force;
                            spheres[i].pulseRate *= 1.1;
                            
                            // Mark as interacting
                            spheres[i].interacting = true;
                            spheres[i].interactionStrength = p.map(d, 0, 300, 1.0, 0.2);
                        }
                    }
                    
                    // Also create a new sphere at mouse position
                    const color = getRandomColor();
                    spheres.push({
                        x: p.mouseX,
                        y: p.mouseY,
                        size: p.random(20, 70),
                        color: color,
                        speedX: p.random(-1, 1),
                        speedY: p.random(-1, 1),
                        connections: [],
                        pulseRate: p.random(0.03, 0.06),
                        pulsePhase: p.random(p.TWO_PI),
                        age: 0,
                        lifespan: p.random(300, 900),
                        adaptDirection: p.random(p.TWO_PI),
                        adaptSpeed: p.random(0.001, 0.005),
                        adaptRadius: p.random(30, 80),
                        interacting: true,
                        interactionStrength: 1.0
                    });
                    
                    // Update connections with the new sphere
                    updateConnections();
                    
                    // We no longer call playHandAnimation since the animation is continuous
                    // But we still need to interact with spheres near the mouse
                    playHandAnimation(p.mouseX, p.mouseY);

                    // Play sound using the more robust function
                    tryPlaySound();
                    
                    lastInteractionTime = Date.now();
                    
                    return false;
                }
            };
            
            // Add touch support for mobile
            p.touchStarted = function() {
                if (p.touches.length > 0) {
                    // Get more accurate touch coordinates
                    const touchX = p.touches[0].x || p.touches[0].clientX;
                    const touchY = p.touches[0].y || p.touches[0].clientY;
                    
                    console.log("Touch detected at:", touchX, touchY);
                    
                    // First ensure audio is initialized on touch
                    p.userStartAudio();
                    
                    // Make sure touch coordinates are within canvas
                    if (touchX > 0 && touchX < p.width && touchY > 0 && touchY < p.height) {
                        // Create a ripple effect
                        for (let i = 0; i < spheres.length; i++) {
                            const d = p.dist(touchX, touchY, spheres[i].x, spheres[i].y);
                            if (d < 300) {
                                // Push spheres slightly away from touch
                                const angle = p.atan2(spheres[i].y - touchY, spheres[i].x - touchX);
                                const force = p.map(d, 0, 300, 3, 0);
                                
                                spheres[i].speedX += p.cos(angle) * force;
                                spheres[i].speedY += p.sin(angle) * force;
                                spheres[i].pulseRate *= 1.1;
                                
                                // Mark as interacting
                                spheres[i].interacting = true;
                                spheres[i].interactionStrength = p.map(d, 0, 300, 1.0, 0.2);
                            }
                        }
                        
                        // Create a new sphere at touch position
                        const color = getRandomColor();
                        spheres.push({
                            x: touchX,
                            y: touchY,
                            size: p.random(20, 70),
                            color: color,
                            speedX: p.random(-1, 1),
                            speedY: p.random(-1, 1),
                            connections: [],
                            pulseRate: p.random(0.03, 0.06),
                            pulsePhase: p.random(p.TWO_PI),
                            age: 0,
                            lifespan: p.random(300, 900),
                            adaptDirection: p.random(p.TWO_PI),
                            adaptSpeed: p.random(0.001, 0.005),
                            adaptRadius: p.random(30, 80),
                            interacting: true,
                            interactionStrength: 1.0
                        });
                        
                        // Update connections
                        updateConnections();
                        
                        // We no longer call playHandAnimation since the animation is continuous
                        // But we still need to interact with spheres near the touch
                        playHandAnimation(touchX, touchY);
                        
                        // Show touch indicator
                        showTouchIndicator(touchX, touchY);
                        
                        // Play sound
                        tryPlaySound();
                        
                        lastInteractionTime = Date.now();
                    }
                }
                
                // Always return false to prevent default behavior
                return false;
            };
            
            p.touchMoved = function() {
                if (p.touches.length > 0) {
                    // Get touch coordinates with fallbacks
                    let touchX, touchY;
                    
                    // Try different ways to get touch coordinates
                    if (p.touches[0].clientX !== undefined) {
                        touchX = p.touches[0].clientX;
                        touchY = p.touches[0].clientY;
                    } else if (p.touches[0].x !== undefined) {
                        touchX = p.touches[0].x;
                        touchY = p.touches[0].y;
                    } else {
                        // Use the canvas-relative touch position
                        touchX = p.touchX;
                        touchY = p.touchY;
                    }
                    
                    try {
                        // Find spheres near the touch
                        let interacted = false;
                        
                        for (let i = 0; i < spheres.length; i++) {
                            const d = p.dist(touchX, touchY, spheres[i].x, spheres[i].y);
                            
                            // Larger interaction radius for touch
                            if (d < 200) {
                                const sphere = spheres[i];
                                
                                // Strength of effect based on distance
                                const strength = p.map(d, 0, 200, 0.15, 0.01);
                                
                                // Create gentle attraction
                                const angle = p.atan2(touchY - sphere.y, touchX - sphere.x);
                                sphere.speedX += p.cos(angle) * strength;
                                sphere.speedY += p.sin(angle) * strength;
                                
                                // For emotional effect, make nearby spheres pulse stronger
                                sphere.pulseRate *= 1.01;
                                
                                // Mark as interacting for visual enhancement
                                sphere.interacting = true;
                                sphere.interactionStrength = p.map(d, 0, 200, 1.0, 0.1);
                                
                                interacted = true;
                                lastInteractionTime = Date.now();
                            }
                        }
                        
                        // Show touch indicator
                        showTouchIndicator(touchX, touchY);
                        
                        if (interacted) {
                            return false; // Prevent default
                        }
                    } catch (error) {
                        console.error("Error in touchMoved:", error);
                    }
                }
                return false; // Always prevent default on mobile
            };
        };
    </script>
</body>
</html>
