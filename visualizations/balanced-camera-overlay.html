<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Balanced Camera Overlay</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <script>
    let cameraCapture;
    let spheres = [];
    let interactionSound; // Sound variable

    const sketch = function(p) {
      p.preload = function() {
        // Load the sound file
        interactionSound = p.loadSound('../audio/balanced-sound.wav');
      };

      p.setup = function() {
        p.createCanvas(p.windowWidth, p.windowHeight);
        
        // Initialize camera capture
        cameraCapture = p.createCapture(p.VIDEO);
        cameraCapture.size(p.windowWidth, p.windowHeight);
        cameraCapture.hide();
        
        // Create initial spheres
        for (let i = 0; i < 15; i++) {
          const color = getRandomColor();
          spheres.push({
            x: p.random(p.width),
            y: p.random(p.height),
            size: p.random(20, 70),
            color: color,
            speedX: p.random(-1, 1),
            speedY: p.random(-1, 1),
            connections: [],
            pulseRate: p.random(0.03, 0.06),
            pulsePhase: p.random(p.TWO_PI),
            age: 0,
            lifespan: p.random(300, 900),
            adaptDirection: p.random(p.TWO_PI),
            adaptSpeed: p.random(0.001, 0.005),
            adaptRadius: p.random(30, 80)
          });
        }
        
        updateConnections();
      };

      p.draw = function() {
        // Draw the camera capture as background
        p.push();
        p.translate(p.width, 0);
        p.scale(-1, 1); // Mirror the camera horizontally
        p.image(cameraCapture, 0, 0, p.width, p.height);
        p.pop();
        
        // Semi-transparent overlay
        p.fill(10, 10, 30, 70);
        p.rect(0, 0, p.width, p.height);
        
        // Update and draw spheres
        updateSpheres();
        drawConnections();
        drawSpheres();
        
        // Create/remove spheres over time
        if (p.frameCount % 60 === 0 && spheres.length < 40 && p.random() < 0.3) {
          const color = getRandomColor();
          spheres.push({
            x: p.random(p.width),
            y: p.random(p.height),
            size: p.random(20, 70),
            color: color,
            speedX: p.random(-1, 1),
            speedY: p.random(-1, 1),
            connections: [],
            pulseRate: p.random(0.03, 0.06),
            pulsePhase: p.random(p.TWO_PI),
            age: 0,
            lifespan: p.random(300, 900),
            adaptDirection: p.random(p.TWO_PI),
            adaptSpeed: p.random(0.001, 0.005),
            adaptRadius: p.random(30, 80)
          });
          updateConnections();
        }
      };

      p.mousePressed = function() {
        // Add interactivity when clicking
        if (p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height) {
          // Create a ripple effect
          for (let i = 0; i < spheres.length; i++) {
            const d = p.dist(p.mouseX, p.mouseY, spheres[i].x, spheres[i].y);
            if (d < 300) {
              // Push spheres slightly away from click
              const angle = p.atan2(spheres[i].y - p.mouseY, spheres[i].x - p.mouseX);
              const force = p.map(d, 0, 300, 3, 0);
              
              spheres[i].speedX += p.cos(angle) * force;
              spheres[i].speedY += p.sin(angle) * force;
              spheres[i].pulseRate *= 1.1;
            }
          }
          
          // Also create a new sphere at mouse position
          const color = getRandomColor();
          spheres.push({
            x: p.mouseX,
            y: p.mouseY,
            size: p.random(20, 70),
            color: color,
            speedX: p.random(-1, 1),
            speedY: p.random(-1, 1),
            connections: [],
            pulseRate: p.random(0.03, 0.06),
            pulsePhase: p.random(p.TWO_PI),
            age: 0,
            lifespan: p.random(300, 900),
            adaptDirection: p.random(p.TWO_PI),
            adaptSpeed: p.random(0.001, 0.005),
            adaptRadius: p.random(30, 80)
          });
          
          // Update connections with the new sphere
          updateConnections();

          // Play sound on interaction
          if (interactionSound && !interactionSound.isPlaying()) {
            interactionSound.play();
          }
          
          return false;
        }
      };

      function updateSpheres() {
        for (let i = spheres.length - 1; i >= 0; i--) {
          const sphere = spheres[i];
          
          // Update position
          sphere.x += sphere.speedX;
          sphere.y += sphere.speedY;
          
          // Gradual slowdown
          sphere.speedX *= 0.99;
          sphere.speedY *= 0.99;
          
          // Adaptive movement
          sphere.adaptDirection += sphere.adaptSpeed;
          sphere.x += Math.cos(sphere.adaptDirection) * 0.2;
          sphere.y += Math.sin(sphere.adaptDirection) * 0.2;
          
          // Boundary checking with bounce
          if (sphere.x < 0 || sphere.x > p.width) {
            sphere.speedX *= -1;
            sphere.x = p.constrain(sphere.x, 0, p.width);
          }
          if (sphere.y < 0 || sphere.y > p.height) {
            sphere.speedY *= -1;
            sphere.y = p.constrain(sphere.y, 0, p.height);
          }
          
          // Age and remove old spheres
          sphere.age++;
          if (sphere.age > sphere.lifespan) {
            spheres.splice(i, 1);
            updateConnections();
          }
        }
      }

      function drawSpheres() {
        for (const sphere of spheres) {
          p.push();
          p.translate(sphere.x, sphere.y);
          
          // Pulse effect
          const pulse = Math.sin(sphere.pulsePhase + p.frameCount * sphere.pulseRate) * 10;
          const size = sphere.size + pulse;
          
          // Base circle
          p.noStroke();
          p.fill(sphere.color[0], sphere.color[1], sphere.color[2], 100);
          p.ellipse(0, 0, size, size);
          
          // Inner highlight
          p.fill(255, 255, 255, 80);
          p.ellipse(-size/5, -size/5, size/3, size/3);
          
          // Age-based border
          const ageRatio = sphere.age / sphere.lifespan;
          p.noFill();
          p.stroke(sphere.color[0], sphere.color[1], sphere.color[2], 180);
          p.strokeWeight(3);
          p.arc(0, 0, size + 10, size + 10, 0, p.TWO_PI * (1 - ageRatio));
          
          p.pop();
        }
      }

      function drawConnections() {
        p.stroke(255, 255, 255, 60);
        p.strokeWeight(1);
        
        for (let i = 0; i < spheres.length; i++) {
          for (const connIdx of spheres[i].connections) {
            const sphere1 = spheres[i];
            const sphere2 = spheres[connIdx];
            
            const d = p.dist(sphere1.x, sphere1.y, sphere2.x, sphere2.y);
            const alpha = p.map(d, 0, 200, 120, 10);
            
            p.stroke(255, 255, 255, alpha);
            p.line(sphere1.x, sphere1.y, sphere2.x, sphere2.y);
            
            // Draw small node at midpoint
            const midX = (sphere1.x + sphere2.x) / 2;
            const midY = (sphere1.y + sphere2.y) / 2;
            p.fill(255, 255, 255, alpha);
            p.noStroke();
            p.ellipse(midX, midY, 3, 3);
          }
        }
      }

      function updateConnections() {
        for (let i = 0; i < spheres.length; i++) {
          spheres[i].connections = [];
          
          for (let j = 0; j < spheres.length; j++) {
            if (i !== j) {
              const d = p.dist(spheres[i].x, spheres[i].y, spheres[j].x, spheres[j].y);
              if (d < 200) {
                spheres[i].connections.push(j);
              }
            }
          }
        }
      }

      function getRandomColor() {
        // Create harmonic color palette
        const palettes = [
          [[64, 224, 208], [255, 140, 0], [147, 112, 219]], // Turquoise, orange, purple
          [[135, 206, 250], [255, 192, 203], [240, 230, 140]], // Light blue, pink, khaki
          [[50, 205, 50], [255, 215, 0], [70, 130, 180]] // Lime green, gold, steel blue
        ];
        
        const palette = palettes[Math.floor(p.random(palettes.length))];
        return palette[Math.floor(p.random(palette.length))];
      }

      p.windowResized = function() {
        p.resizeCanvas(p.windowWidth, p.windowHeight);
        if (cameraCapture) {
          cameraCapture.size(p.windowWidth, p.windowHeight);
        }
      };
    };

    new p5(sketch);
  </script>
</body>
</html>
