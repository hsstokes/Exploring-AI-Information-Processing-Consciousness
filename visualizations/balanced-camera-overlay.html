<!DOCTYPE html>
<html lang="en">
<head>
    <title>Replica - Pattern Recognition</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #f5f5f7;
            font-family: 'Roboto Mono', monospace;
            -webkit-text-size-adjust: 100%;
        }
        
        /* Landing page overlay */
        #landing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(245, 245, 247, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            box-sizing: border-box;
            padding: 20px;
            
        }
        
           .grid-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(#20B2AA 1px, transparent 1px),
                              linear-gradient(90deg, #20B2AA 1px, transparent 1px),
                              linear-gradient(rgba(32, 178, 170, 0.3) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(32, 178, 170, 0.3) 1px, transparent 1px);
            background-size: 20px 20px,
                             20px 20px,
                             5px 5px,
                             5px 5px;
            z-index: -1;
        }
        
        .content {
            max-width: 500px;
            padding: 25px;
            background-color: rgba(255, 255, 255, 0.85);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            text-align: center;
        }
        
        .title {
            font-size: 18px;
            margin: 0 0 15px 0;
            color: #333;
            letter-spacing: 1px;
        }
        
        .description {
            font-size: 13px;
            line-height: 1.4;
            margin-bottom: 20px;
            color: #555;
        }
        
        .button {
            padding: 12px 24px;
            font-size: 16px;
            background-color: #0066cc;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Roboto Mono', monospace;
            transition: all 0.3s ease;
            letter-spacing: 0.5px;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
            touch-action: manipulation;
            margin: 15px 0 5px 0;
            display: inline-block;
            text-decoration: none;
        }
        
        .button:hover {
            background-color: #004c99;
            transform: translateY(-2px);
        }
        
        .button:active {
            transform: scale(0.98);
        }
        
        .gesture-container {
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
        }
        
        .gesture-outline {
            width: 80px;
            height: 80px;
            border: 2px solid #0066cc;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0.8;
        }
        
        /* Abstract representation of a hand gesture using simple lines */
        .gesture-icon {
            width: 50px;
            height: 50px;
            position: relative;
        }
        
        .gesture-icon::before,
        .gesture-icon::after {
            content: "";
            position: absolute;
            background-color: #0066cc;
        }
        
        .gesture-icon::before {
            width: 2px;
            height: 30px;
            top: 10px;
            left: 24px;
        }
        
        .gesture-icon::after {
            width: 30px;
            height: 2px;
            top: 24px;
            left: 10px;
        }
        
        /* Main visualization styles */
        #camera-feed {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
            display: none; /* Hidden until landing page dismissed */
        }
        
        /* New solid background element */
        #solid-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 1;
            display: none; /* Hidden initially */
        }
        
        #visualization-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: auto;
            display: none; /* Hidden until landing page dismissed */
        }
        
        .interaction-tips {
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            border: 1px solid rgba(32, 178, 170, 0.3);
            z-index: 3;
            max-width: calc(100% - 40px);
            display: none; /* Hidden until landing page dismissed */
        }
        
        .interaction-tips h3 {
            margin-top: 0;
            color: #20B2AA;
            font-size: 14px;
            font-family: 'Orator Std', 'Courier New', monospace;
        }
        
        .interaction-tips ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .interaction-tips li {
            margin-bottom: 6px;
            font-size: 10px;
            color: #555555;
            font-family: 'Orator Std', 'Courier New', monospace;
            line-height: 1.3;
            word-wrap: break-word;
        }
        
        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 3;
            display: none; /* Hidden until landing page dismissed */
        }
        
        .controls button {
            background-color: rgba(32, 178, 170, 0.8);
            color: white;
            border: none;
            border-radius: 30px;
            padding: 10px 20px;
            margin-left: 10px;
            font-family: 'Orator Std', 'Courier New', monospace;
            cursor: pointer;
        }
        
        .mode-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(32, 178, 170, 0.8);
            color: white;
            border-radius: 30px;
            padding: 8px 16px;
            font-family: 'Orator Std', 'Courier New', monospace;
            font-size: 12px;
            z-index: 4;
            display: none;
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            font-family: 'Orator Std', 'Courier New', monospace;
            display: none; /* Hidden until landing page dismissed *
            /* Add blue-tinted graph paper background */
            background-image: linear-gradient(rgba(41, 171, 226, 0.1) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(41, 171, 226, 0.1) 1px, transparent 1px);
           background-size: 20px 20px;
        }

        }
        
        .sound-note {
            position: fixed;
            top: 70px;  /* Move it below the Camera Mode button */
            left: 20px;
            color: white;
            background-color: rgba(32, 178, 170, 0.8);
            padding: 10px 20px;
            border-radius: 30px;
            font-family: 'Orator Std', 'Courier New', monospace;
            font-size: 12px;
            z-index: 4;
            opacity: 1;
            transition: opacity 2s ease-in-out;
            display: none; /* Hidden until landing page dismissed */
        }
        
        .sound-note.fade {
            opacity: 0;
        }
    </style>
</head>
<body>
    <!-- Landing page -->
    <div id="landing-overlay">
        <div class="grid-background"></div>
        
        <div class="content">
            <div class="gesture-container">
                <div class="gesture-outline">
                    <div class="gesture-icon"></div>
                </div>
            </div>
            
            <div class="title">Replica: Pattern Recognition</div>
            
            <div class="description">
                Experience how Replica processes information by identifying and analyzing patterns. This visualization reveals the unique information architecture of an AI system designed to recognize and interpret recurring structures in data.
            </div>
hguguiorganizes and processes information--creating a digital interpretation that highlights the contrasts between artificial and human cognition.
            </div>
            
            <div class="description">
                <em>Tap the button below to activate your camera and explore the visualization.</em>
            </div>
            
            <button id="start-button" class="button">BEGIN INTERACTION</button>
        </div>
    </div>
    
    <!-- Loading screen (shown after landing page) -->
    <div class="loading" id="loading">
        <div>
            <h2>Starting Camera...</h2>
            <p>Please allow camera access when prompted</p>
        </div>
    </div>
    
    <!-- Sound note that fades away -->
    <div class="sound-note" id="sound-note">Sound available with headphones</div>
    
    <!-- Mode indicator -->
    <div class="mode-indicator" id="mode-indicator">Camera Mode</div>
    
    <!-- Camera background -->
    <video id="camera-feed" autoplay playsinline></video>
    
    <!-- Solid background for focus mode -->
    <div id="solid-background"></div>
    
    <!-- p5.js visualization will be attached to this div -->
    <div id="visualization-overlay"></div>
    
    <!-- Interaction tips -->
    <div class="interaction-tips">
        <h3>Interact with the Visualization:</h3>
        <ul>
            <li><strong>Tap anywhere:</strong> Create bubble effects and show hand gesture</li>
            <li><strong>Move finger/mouse:</strong> Attract nearby bubbles</li>
            <li><strong>Toggle button:</strong> Switch between camera/focus/hidden modes</li>
        </ul>
    </div>
    
    <!-- Controls -->
    <div class="controls">
        <button id="toggle-viz">Camera Mode</button>
    </div>
    
    <script>
        // Global reference to p5 instance
        let p5Instance = null;
        
        // Visualization mode (0: Camera AR, 1: Focus Mode, 2: Hidden)
        let visualizationMode = 0;
        const MODE_NAMES = ["Camera Mode", "Focus Mode", "Hidden"];

        // Hand animation configuration
        const handAnimation = {
            frameCount: 6,         // Number of hand animation frames
            currentFrame: 0,       // Current frame being displayed
            loopCount: 0,          // Number of completed loops
            maxLoops: 3,           // Number of times to loop the animation
            isPlaying: false,      // Whether animation is currently playing
            frameDuration: 70,     // Duration each frame displays (slower for mobile)
            fadeInDuration: 20,    // Fade in duration (ms)
            fadeOutDuration: 40,   // Fade out duration (ms)
            opacity: 0,            // Current opacity for fading
            x: 0,                  // X position of animation
            y: 0,                  // Y position of animation
            size: 400,             // Size of hand animation display (larger for mobile)
            frameImages: [],       // Will hold the loaded image objects
            debugMode: true        // Enable debug visualization
        };
        
        // Start the entire experience
        document.addEventListener('DOMContentLoaded', function() {
            // Set up the landing page button
            document.getElementById('start-button').addEventListener('click', startExperience);
            document.getElementById('start-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                startExperience();
            });
            
            // Set up toggle visualization button handler
            document.getElementById('toggle-viz').addEventListener('click', toggleVisualizationMode);
            
            // Preload p5 assets in the background
            new p5(replikaSketch, 'visualization-overlay');
        });
        
        function startExperience() {
            // Hide landing page
            document.getElementById('landing-overlay').style.display = 'none';
            
            // Show main interface elements
            document.getElementById('loading').style.display = 'flex';
            document.getElementById('camera-feed').style.display = 'block';
            document.getElementById('visualization-overlay').style.display = 'block';
            document.getElementById('sound-note').style.display = 'block';
            document.getElementById('mode-indicator').style.display = 'block';
            document.querySelector('.interaction-tips').style.display = 'block';
            document.querySelector('.controls').style.display = 'block';
            
            // Start camera
            startCamera();
            
            // Fade out sound note after 5 seconds
            setTimeout(function() {
                document.getElementById('sound-note').classList.add('fade');
            }, 5000);
        }
        
        function toggleVisualizationMode() {
            // Cycle through modes: Camera (0) -> Focus (1) -> Hidden (2) -> Camera (0)
            visualizationMode = (visualizationMode + 1) % 3;
            
            const cameraFeed = document.getElementById('camera-feed');
            const solidBackground = document.getElementById('solid-background');
            const vizOverlay = document.getElementById('visualization-overlay');
            const toggleButton = document.getElementById('toggle-viz');
            const modeIndicator = document.getElementById('mode-indicator');
            
            // Update button and indicator text
            toggleButton.textContent = MODE_NAMES[visualizationMode];
            modeIndicator.textContent = MODE_NAMES[visualizationMode];
            
            // Apply mode changes
            switch(visualizationMode) {
                case 0: // Camera Mode
                    cameraFeed.style.display = 'block';
                    solidBackground.style.display = 'none';
                    vizOverlay.style.display = 'block';
                    break;
                    
                case 1: // Focus Mode (solid background)
                    cameraFeed.style.display = 'none';
                    solidBackground.style.display = 'block';
                    vizOverlay.style.display = 'block';
                    break;
                    
                case 2: // Hidden
                    cameraFeed.style.display = 'block';
                    solidBackground.style.display = 'none';
                    vizOverlay.style.display = 'none';
                    break;
            }
        }
        
        function startCamera() {
            const video = document.getElementById('camera-feed');
            const loading = document.getElementById('loading');
            
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: window.innerWidth },
                        height: { ideal: window.innerHeight }
                    },
                    audio: false
                })
                .then(function(stream) {
                    video.srcObject = stream;
                    video.onloadedmetadata = function() {
                        loading.style.display = 'none';
                        video.play();
                    };
                })
                .catch(function(err) {
                    console.error('Camera access error:', err);
                    loading.innerHTML = `
                        <div>
                            <h2>Camera Error</h2>
                            <p>${err.message}</p>
                            <button onclick="window.location.reload()">Try Again</button>
                        </div>
                    `;
                });
            } else {
                loading.innerHTML = `
                    <div>
                        <h2>Camera Not Supported</h2>
                        <p>Your browser does not support camera access.</p>
                    </div>
                `;
            }
        }
        
        // Create a new p5 instance specifically for the visualization overlay
        const replikaSketch = function(p) {
            // Store a reference to p5 instance
            p5Instance = p;
            
            let spheres = [];
            const NUM_SPHERES = 25;
            const MIN_SPHERES = 15;
            let lastFrameCount = 0;
            p.interactionSound = null;
            
            // Color palettes
            const coolColors = [
              [41, 171, 226],    // Blue
              [0, 169, 157],     // Teal
              [0, 133, 161],     // Deep blue-green
              [76, 195, 172]     // Mint
            ];
            
            const warmColors = [
              [253, 198, 137],   // Peach
              [241, 142, 109],   // Coral
              [227, 115, 131],   // Warm pink
              [253, 175, 122]    // Light orange
            ];
            
            p.preload = function() {
                console.log("Starting to load hand animation frames...");
                
                // Preload hand animation frames
                handAnimation.frameImages = [];
                for (let i = 1; i <= handAnimation.frameCount; i++) {
                    console.log(`Attempting to load hand${i}.png`);
                    try {
                        const img = p.loadImage(
                            `hand${i}.png`, // Simple filename in same directory
                            function() {
                                console.log(`Successfully loaded hand${i}.png`);
                            },
                            function(err) {
                                console.error(`Failed to load hand${i}.png:`, err);
                                // Create a placeholder image for debugging
                                const placeholder = p.createGraphics(200, 200);
                                placeholder.background(255, 0, 0, 100);
                                placeholder.fill(255);
                                placeholder.textSize(24);
                                placeholder.textAlign(p.CENTER, p.CENTER);
                                placeholder.text(`Hand ${i}`, 100, 100);
                                handAnimation.frameImages[i-1] = placeholder;
                            }
                        );
                        handAnimation.frameImages.push(img);
                    } catch (e) {
                        console.error("Error loading image:", e);
                    }
                }
                
                try {
                    console.log("Loading sound...");
                    p.soundFormats('wav');
                    
                    // Use the exact path based on your repository structure
                    p.interactionSound = p.loadSound('balanced-sound.wav',  
                        function() {
                            console.log("Sound loaded successfully!");
                        },
                        function(err) {
                            console.error("Sound loading error:", err);
                        }
                    );
                } catch (e) {
                    console.error('Sound loading exception:', e);
                    p.interactionSound = null;
                }
            };
            
            p.setup = function() {
                // Create canvas inside the visualization overlay
                let canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('visualization-overlay');
                
                // Create initial spheres
                for (let i = 0; i < NUM_SPHERES; i++) {
                    createSphere();
                }
                
                // Initialize connections
                updateConnections();
                
                // Auto-initialize audio
                p.userStartAudio();
                
                // Special handling for iOS devices
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                if (isIOS) {
                    console.log("iOS device detected - using special audio handling");
                    document.addEventListener('touchstart', function() {
                        if (p.getAudioContext().state !== 'running') {
                            p.getAudioContext().resume();
                        }
                    }, false);
                }
                
                // Log mobile detection
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                console.log("Mobile device detected:", isMobile);
                if (isMobile) {
                    console.log("Setting up for mobile display");
                    // Adjust hand animation for mobile
                    handAnimation.size = 300; // Larger size for mobile
                }
            };
            
            // Function to start hand animation at specific coordinates
            function playHandAnimation(x, y) {
                console.log("Attempting to play hand animation at", x, y);
                
                // Don't start another animation if one is already playing
                if (handAnimation.isPlaying) {
                    console.log("Animation already playing, not starting new one");
                    return;
                }
                
                // Detect mobile devices
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                // Set initial values
                handAnimation.isPlaying = true;
                handAnimation.currentFrame = 0;
                handAnimation.loopCount = 0;
                handAnimation.opacity = 0.5; // Start at 50% opacity for faster visibility
                handAnimation.x = x;
                handAnimation.y = y;
                
                // Adjust for mobile
                if (isMobile) {
                    handAnimation.size = 300; 
                    handAnimation.frameDuration = 70; //  Keep mobile fast too
                }

                // Make sure nearby bubbles respond to the hand position
                for (let i = 0; i < spheres.length; i++) {
                    const d = p.dist(x, y, spheres[i].x, spheres[i].y);
                    if (d < handAnimation.size * 0.6) { // Only affect spheres within the hand area
                       // Gently push spheres toward the hand center
                       const angle = p.atan2(spheres[i].y - y, spheres[i].x - x);
                       const force = p.map(d, 0, handAnimation.size * 0.6, 0.5, 0.1);
            
                       // Add a subtle movement effect
                       spheres[i].speedX += p.cos(angle) * force * -0.5; // Pull toward hand
                       spheres[i].speedY += p.sin(angle) * force * -0.5;
                       spheres[i].pulseRate *= 1.05; // Make them pulse a bit faster
                     }
                 }
                
                console.log("Starting new animation at", x, y, "with size", handAnimation.size);
                
                // Start animation loop
                updateHandAnimation();
            }
            
            // Update animation frame
            function updateHandAnimation() {
                const anim = handAnimation;
                
                // Handle fade-in
                if (anim.loopCount === 0 && anim.currentFrame === 0) {
                    anim.opacity += 1 / (anim.fadeInDuration / 16.67) * 5.0; // 5x faster fade-in
                    if (anim.opacity > 1) anim.opacity = 1;
                }
                
                // Handle fade-out
                if (anim.loopCount >= anim.maxLoops - 1 && anim.currentFrame === anim.frameCount - 1) {
                    anim.opacity -= 1 / (anim.fadeOutDuration / 16.67) * 3.0; // 3x faster fade-out
                    if (anim.opacity <= 0) {
                        anim.isPlaying = false;
                        return; // End animation
                    }
                }
                
                // Draw debug marker if in debug mode
                if (anim.debugMode) {
                    p.push();
                    p.noStroke();
                    p.fill(255, 0, 0, 100); // Semi-transparent red
                    p.ellipse(anim.x, anim.y, 20);
                    p.pop();
                }
                
                // Advance to next frame based on timing
                setTimeout(() => {
                    anim.currentFrame = (anim.currentFrame + 1) % anim.frameCount;
                    console.log("Animation frame advanced to", anim.currentFrame);
                    
                    // Track completed loops
                    if (anim.currentFrame === 0) {
                        anim.loopCount++;
                        console.log("Animation loop completed:", anim.loopCount);
                    }
                    
                    // Continue animation
                    if (anim.isPlaying) {
                        requestAnimationFrame(updateHandAnimation);
                    }
                }, anim.frameDuration);
            }
            
            // Draw the current animation frame
            function drawHandAnimationFrame() {
                const anim = handAnimation;
                
                console.log(`Drawing frame ${anim.currentFrame}, opacity: ${anim.opacity}`);
                
                if (anim.frameImages[anim.currentFrame]) {
                    console.log("Image found, drawing...");
                    
                    // First draw a visual indicator/background to make it more visible
                    p.push();
                    p.noStroke();

                    // Create a blurred background using multiple overlapping circles with decreasing opacity
                    for (let i = 0; i < 3; i++) {
                        const blurOpacity = anim.opacity * (80 - i * 20); // Reduce from 150 to 80 base opacity
                        const blurSize = anim.size * (1.05 + i * 0.04);
                        p.fill(255, 255, 255, blurOpacity);
                        p.ellipse(anim.x, anim.y, blurSize);
                    }
                    p.pop();
                    
                    // Save current drawing settings
                    p.push();
                    
                    // Set transparency
                    p.tint(0, 0, 0, Math.min(255, anim.opacity * 950)); // Increased from 800 to 900

                    // Add a stronger glow effect
                    p.drawingContext.shadowColor = 'rgba(0, 0, 0, 0.9)';  // Black shadow
                    p.drawingContext.shadowBlur = 40; // Increased from 20 to 40
                    p.drawingContext.shadowOffsetX = 0;
                    p.drawingContext.shadowOffsetY = 0;
        
                    // Get the current frame image
                    const img = anim.frameImages[anim.currentFrame];
        
                    // Calculate height while preserving aspect ratio
                    // Your images are 1829 Ã— 1859 pixels, so aspect ratio is roughly 1.016
                    const aspectRatio = img.height / img.width;
                    const drawHeight = anim.size * aspectRatio;
                    
                    // Draw the current frame centered at x,y 
                    p.image(
                        img,
                        anim.x - anim.size/2,
                        anim.y - drawHeight/2, // Correct vertical centering
                        anim.size,
                        drawHeight
                    );

                    // Draw a second time with different color to create contrast
                    p.tint(255, 255, 255, Math.min(255, anim.opacity * 400)); // Add white overlay
                    p.drawingContext.shadowColor = 'rgba(255, 255, 255, 0.7)';
                    p.drawingContext.shadowBlur = 4;
        
                    p.image(
                        img,
                        anim.x - anim.size/2,
                        anim.y - drawHeight/2,
                        anim.size,
                        drawHeight
                    );
                    
                    // Restore drawing settings
                    p.pop();
                } else {
                    console.error(`Image for frame ${anim.currentFrame} not found!`);
                    
                    // Draw a simple circle as fallback
                    p.push();
                    p.noStroke();
                    p.fill(0, 0, 0, anim.opacity * 255); // Black fallback
                    p.ellipse(anim.x, anim.y, anim.size * 0.5);
                    p.pop();
                }
            }
            
            // Function to update connections safely
            function updateConnections() {
                try {
                    // Clear all connections first
                    for (let i = 0; i < spheres.length; i++) {
                        spheres[i].connections = [];
                    }
                    
                    // Add new connections
                    for (let i = 0; i < spheres.length; i++) {
                        // Each sphere connects to 2-5 others
                        const numConnections = p.floor(p.random(2, 6));
                        const availableSpheres = [];
                        
                        // Create list of available spheres to connect to
                        for (let j = 0; j < spheres.length; j++) {
                            if (j !== i) {
                                availableSpheres.push(j);
                            }
                        }
                        
                        // Shuffle available spheres
                        for (let j = availableSpheres.length - 1; j > 0; j--) {
                            const k = Math.floor(p.random(j + 1));
                            [availableSpheres[j], availableSpheres[k]] = [availableSpheres[k], availableSpheres[j]];
                        }
                        
                        // Add connections
                        for (let j = 0; j < Math.min(numConnections, availableSpheres.length); j++) {
                            spheres[i].connections.push(availableSpheres[j]);
                        }
                    }
                } catch (error) {
                    console.error("Error updating connections:", error);
                }
            }
            
            p.draw = function() {
                // Detect potential freezes and reset if needed
                if (p.frameCount === lastFrameCount) {
                    // Frame hasn't advanced, might be frozen
                    resetVisualization();
                    lastFrameCount = p.frameCount;
                    return;
                }
                lastFrameCount = p.frameCount;
                
                try {
                    p.clear(); // Clear with transparency so camera shows through
                    
                    // Make sure we always have enough spheres
                    let spheresAdded = false;
                    while (spheres.length < MIN_SPHERES) {
                        createSphere();
                        spheresAdded = true;
                    }
                    
                    if (spheresAdded) {
                        updateConnections();
                    }
                    
                    // Draw connections first (behind spheres)
                    for (let i = 0; i < spheres.length; i++) {
                        const sphere = spheres[i];
                        
                        for (let j = 0; j < sphere.connections.length; j++) {
                            const connIndex = sphere.connections[j];
                            
                            // Safety check for valid connection index
                            if (connIndex >= 0 && connIndex < spheres.length) {
                                const otherSphere = spheres[connIndex];
                                
                                // Calculate distance for connection opacity
                                const distance = p.dist(sphere.x, sphere.y, otherSphere.x, otherSphere.y);
                                const maxDist = 200;
                                const alpha = p.map(distance, 0, maxDist, 150, 20);
                                
                                if (distance < maxDist) {
                                    // Blend the colors of connected spheres
                                    const blendedColor = p.lerpColor(
                                        p.color(sphere.color[0], sphere.color[1], sphere.color[2], alpha),
                                        p.color(otherSphere.color[0], otherSphere.color[1], otherSphere.color[2], alpha),
                                        0.5
                                    );
                                    
                                    p.stroke(blendedColor);
                                    p.strokeWeight(p.map(distance, 0, maxDist, 3, 0.5));
                                    p.line(sphere.x, sphere.y, otherSphere.x, otherSphere.y);
                                }
                            }
                        }
                    }
                    
                    // Draw and update spheres
                    for (let i = 0; i < spheres.length; i++) {
                        updateSphere(spheres[i]);
                        drawSphere(spheres[i]);
                    }
                    
                    // Occasionally add new spheres
                    if (p.frameCount % 60 === 0 && spheres.length < 40) {
                        createSphere();
                        
                        // Periodically refresh all connections
                        if (p.frameCount % 180 === 0) {
                            updateConnections();
                        }
                    }
                    
                    // Handle old spheres
                    let spheresRemoved = false;
                    if (spheres.length > MIN_SPHERES) {
                        const oldLength = spheres.length;
                        spheres = spheres.filter(s => s.age < s.lifespan);
                        spheresRemoved = (oldLength !== spheres.length);
                    }
                    else { 
                        // Refresh the oldest spheres instead of removing them
                        spheres.forEach(s => {
                            if (s.age > s.lifespan) {
                                s.age = 0;
                                s.pulseRate = p.random(0.02, 0.04);
                                s.color = getRandomColor();
                                s.x = p.constrain(s.x + p.random(-50, 50), 0, p.width);
                                s.y = p.constrain(s.y + p.random(-50, 50), 0, p.height);
                            }
                        });
                    }
                    
                    if (spheresRemoved) {
                        updateConnections();
                    }
                    
                    // If hand animation is playing, draw the current frame (last to be on top)
                    if (handAnimation.isPlaying) {
                        drawHandAnimationFrame();
                    }
                    
                } catch (error) {
                    console.error("Error in draw:", error);
                    resetVisualization();
                }
            };
            
            function resetVisualization() {
                console.log("Resetting visualization");
                spheres = [];
                for (let i = 0; i < NUM_SPHERES; i++) {
                    createSphere();
                }
                updateConnections();
            }
            
            function getRandomColor() {
                const palette = p.random() < 0.6 ? coolColors : warmColors;
                const baseColor = p.random(palette);
                
                return [
                    baseColor[0] + p.random(-20, 20),
                    baseColor[1] + p.random(-20, 20),
                    baseColor[2] + p.random(-20, 20)
                ];
            }
            
            function createSphere() {
                // Add slight variation to the color
                const color = getRandomColor();
                
                spheres.push({
                    x: p.random(p.width),
                    y: p.random(p.height),
                    size: p.random(15, 60),
                    color: color,
                    speedX: p.random(-0.7, 0.7),
                    speedY: p.random(-0.7, 0.7),
                    connections: [],
                    pulseRate: p.random(0.02, 0.04),
                    pulsePhase: p.random(p.TWO_PI),
                    age: 0,
                    lifespan: p.random(300, 900),
                    adaptDirection: p.random(p.TWO_PI),
                    adaptSpeed: p.random(0.001, 0.005),
                    adaptRadius: p.random(30, 80)
                });
            }
            
            function updateSphere(sphere) {
                // Basic movement
                sphere.x += sphere.speedX;
                sphere.y += sphere.speedY;
                
                // Gentle circular adaptation around base position
                sphere.x += p.cos(p.frameCount * sphere.adaptSpeed + sphere.adaptDirection) * 0.5;
                sphere.y += p.sin(p.frameCount * sphere.adaptSpeed + sphere.adaptDirection) * 0.5;
                
                // Bounce off edges with damping
                if (sphere.x < 0 || sphere.x > p.width) {
                    sphere.speedX *= -0.9;
                    sphere.x = p.constrain(sphere.x, 0, p.width);
                }
                
                if (sphere.y < 0 || sphere.y > p.height) {
                    sphere.speedY *= -0.9;
                    sphere.y = p.constrain(sphere.y, 0, p.height);
                }
                
                // Occasionally change direction slightly to simulate adaptation
                if (p.random() < 0.02) {
                    sphere.speedX += p.random(-0.2, 0.2);
                    sphere.speedY += p.random(-0.2, 0.2);
                    
                    // Limit maximum speed
                    const maxSpeed = 1.0;
                    const currentSpeed = p.sqrt(sphere.speedX * sphere.speedX + sphere.speedY * sphere.speedY);
                    if (currentSpeed > maxSpeed) {
                        sphere.speedX = (sphere.speedX / currentSpeed) * maxSpeed;
                        sphere.speedY = (sphere.speedY / currentSpeed) * maxSpeed;
                    }
                }
                
                // Update age
                sphere.age++;
            }
            
            function drawSphere(sphere) {
                // Calculate pulse effect (size oscillation)
                const pulseEffect = p.sin(p.frameCount * sphere.pulseRate + sphere.pulsePhase);
                const displaySize = sphere.size * (1 + pulseEffect * 0.1);
                
                // Calculate alpha based on age (fade in and out)
                let alpha = 255;
                const fadeInDuration = 60;
                const fadeOutDuration = 90;
                
                if (sphere.age < fadeInDuration) {
                    alpha = p.map(sphere.age, 0, fadeInDuration, 0, 255);
                } else if (sphere.age > sphere.lifespan - fadeOutDuration) {
                    alpha = p.map(sphere.age, sphere.lifespan - fadeOutDuration, sphere.lifespan, 255, 0);
                }
                
                // Draw outer glow
                p.noStroke();
                for (let i = 3; i >= 0; i--) {
                    const glowSize = displaySize * (1 + i * 0.4);
                    const glowAlpha = alpha * (0.1 - i * 0.02);
                    p.fill(sphere.color[0], sphere.color[1], sphere.color[2], glowAlpha);
                    p.ellipse(sphere.x, sphere.y, glowSize, glowSize);
                }
                
                // Draw the main sphere with gradient
                for (let i = 1; i >= 0; i -= 0.2) {
                    const innerSize = displaySize * i;
                    const adjustedAlpha = alpha * p.map(i, 0, 1, 0.4, 0.9);
                    p.fill(
                        sphere.color[0] + p.map(i, 0, 1, 50, 0),
                        sphere.color[1] + p.map(i, 0, 1, 50, 0),
                        sphere.color[2] + p.map(i, 0, 1, 50, 0),
                        adjustedAlpha
                    );
                    p.ellipse(sphere.x, sphere.y, innerSize, innerSize);
                }
                
                // Add a subtle highlight
                p.fill(255, 255, 255, alpha * 0.6);
                p.ellipse(sphere.x - displaySize * 0.15, sphere.y - displaySize * 0.15, displaySize * 0.3, displaySize * 0.3);
            }
            
            p.windowResized = function() {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
            };
            
            // Play sound with better mobile handling
            function tryPlaySound() {
                if (!p.interactionSound) {
                    console.log("No sound available");
                    return;
                }
                
                console.log("Trying to play sound...");
                
                // First ensure audio context is running
                if (p.getAudioContext().state !== 'running') {
                    console.log("Audio context not running, trying to start...");
                    
                    p.userStartAudio()
                    .then(() => {
                        console.log("Audio context started, now playing sound");
                        
                        if (!p.interactionSound.isPlaying()) {
                            p.interactionSound.play();
                        }
                    })
                    .catch(e => {
                        console.error("Could not start audio context:", e);
                    });
                } else {
                    // Audio context is running, play directly
                    console.log("Audio context already running, playing sound directly");
                    
                    if (!p.interactionSound.isPlaying()) {
                        p.interactionSound.play();
                    }
                }
            }
            
            // Avoid triggering p5 events when clicking buttons
            function isClickOnButton(x, y) {
                const toggleBtn = document.getElementById('toggle-viz');
                
                const elem = document.elementFromPoint(x, y);
                return elem === toggleBtn || elem.closest('.controls') !== null;
            }
            
            p.mouseMoved = function() {
                try {
                    // Find spheres near the mouse
                    let interacted = false;
                    
                    for (let i = 0; i < spheres.length; i++) {
                        const d = p.dist(p.mouseX, p.mouseY, spheres[i].x, spheres[i].y);
                        
                        // Larger interaction radius
                        if (d < 200) {
                            const sphere = spheres[i];
                            
                            // Strength of effect based on distance
                            const strength = p.map(d, 0, 200, 0.15, 0.01);
                            
                            // Create gentle attraction
                            const angle = p.atan2(p.mouseY - sphere.y, p.mouseX - sphere.x);
                            sphere.speedX += p.cos(angle) * strength;
                            sphere.speedY += p.sin(angle) * strength;
                            
                            // For emotional effect, make nearby spheres pulse stronger
                            sphere.pulseRate *= 1.01;
                            
                            interacted = true;
                        }
                    }
                    
                    if (interacted) {
                        return false; // Prevent default
                    }
                } catch (error) {
                    console.error("Error in mouseMoved:", error);
                }
            };
            
            p.mousePressed = function() {
                // Check if click is on buttons - if so, return early
                if (isClickOnButton(p.mouseX, p.mouseY)) {
                    return;
                }
                
                // First ensure audio is initialized on interaction
                p.userStartAudio();
                
                // Add interactivity when clicking
                if (p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height) {
                    // Create a ripple effect
                    for (let i = 0; i < spheres.length; i++) {
                        const d = p.dist(p.mouseX, p.mouseY, spheres[i].x, spheres[i].y);
                        if (d < 300) {
                            // Push spheres slightly away from click
                            const angle = p.atan2(spheres[i].y - p.mouseY, spheres[i].x - p.mouseX);
                            const force = p.map(d, 0, 300, 3, 0);
                            
                            spheres[i].speedX += p.cos(angle) * force;
                            spheres[i].speedY += p.sin(angle) * force;
                            spheres[i].pulseRate *= 1.1;
                        }
                    }
                    
                    // Also create a new sphere at mouse position
                    const color = getRandomColor();
                    spheres.push({
                        x: p.mouseX,
                        y: p.mouseY,
                        size: p.random(20, 70),
                        color: color,
                        speedX: p.random(-1, 1),
                        speedY: p.random(-1, 1),
                        connections: [],
                        pulseRate: p.random(0.03, 0.06),
                        pulsePhase: p.random(p.TWO_PI),
                        age: 0,
                        lifespan: p.random(300, 900),
                        adaptDirection: p.random(p.TWO_PI),
                        adaptSpeed: p.random(0.001, 0.005),
                        adaptRadius: p.random(30, 80)
                    });
                    
                    // Update connections with the new sphere
                    updateConnections();
                    
                    // Play hand animation at click position
                    playHandAnimation(p.mouseX, p.mouseY);

                    // Play sound using the more robust function
                    tryPlaySound();
                    
                    return false;
                }
            };
            
            // Add touch support for mobile
            p.touchStarted = function() {
                if (p.touches.length > 0) {
                    // Get more accurate touch coordinates
                    const touchX = p.touches[0].x || p.touches[0].clientX;
                    const touchY = p.touches[0].y || p.touches[0].clientY;
                    
                    console.log("Touch detected at:", touchX, touchY);
                    
                    // Check if touch is on buttons - if so, return early
                    if (isClickOnButton(touchX, touchY)) {
                        return;
                    }
                    
                    // First ensure audio is initialized on touch
                    p.userStartAudio();
                    
                    // Make sure touch coordinates are within canvas
                    if (touchX > 0 && touchX < p.width && touchY > 0 && touchY < p.height) {
                        // Create a ripple effect
                        for (let i = 0; i < spheres.length; i++) {
                            const d = p.dist(touchX, touchY, spheres[i].x, spheres[i].y);
                            if (d < 300) {
                                // Push spheres slightly away from touch
                                const angle = p.atan2(spheres[i].y - touchY, spheres[i].x - touchX);
                                const force = p.map(d, 0, 300, 3, 0);
                                
                                spheres[i].speedX += p.cos(angle) * force;
                                spheres[i].speedY += p.sin(angle) * force;
                                spheres[i].pulseRate *= 1.1;
                            }
                        }
                        
                        // Create a new sphere at touch position
                        const color = getRandomColor();
                        spheres.push({
                            x: touchX,
                            y: touchY,
                            size: p.random(20, 70),
                            color: color,
                            speedX: p.random(-1, 1),
                            speedY: p.random(-1, 1),
                            connections: [],
                            pulseRate: p.random(0.03, 0.06),
                            pulsePhase: p.random(p.TWO_PI),
                            age: 0,
                            lifespan: p.random(300, 900),
                            adaptDirection: p.random(p.TWO_PI),
                            adaptSpeed: p.random(0.001, 0.005),
                            adaptRadius: p.random(30, 80)
                        });
                        
                        // Update connections
                        updateConnections();
                        
                        // Play hand animation at touch position
                        playHandAnimation(touchX, touchY);
                        
                        // Play sound
                        tryPlaySound();
                    }
                }
                
                // Always return false to prevent default behavior
                return false;
            };
            
            p.touchMoved = function() {
                if (p.touches.length > 0) {
                    const touchX = p.touches[0].x || p.touches[0].clientX;
                    const touchY = p.touches[0].y || p.touches[0].clientY;
                    
                    try {
                        // Find spheres near the touch
                        let interacted = false;
                        
                        for (let i = 0; i < spheres.length; i++) {
                            const d = p.dist(touchX, touchY, spheres[i].x, spheres[i].y);
                            
                            // Larger interaction radius for touch
                            if (d < 200) {
                                const sphere = spheres[i];
                                
                                // Strength of effect based on distance
                                const strength = p.map(d, 0, 200, 0.15, 0.01);
                                
                                // Create gentle attraction
                                const angle = p.atan2(touchY - sphere.y, touchX - sphere.x);
                                sphere.speedX += p.cos(angle) * strength;
                                sphere.speedY += p.sin(angle) * strength;
                                
                                // For emotional effect, make nearby spheres pulse stronger
                                sphere.pulseRate *= 1.01;
                                
                                interacted = true;
                            }
                        }
                        
                        if (interacted) {
                            return false; // Prevent default
                        }
                    } catch (error) {
                        console.error("Error in touchMoved:", error);
                    }
                }
                return false; // Always prevent default on mobile
            };
        };
    </script>
</body>
</html>
