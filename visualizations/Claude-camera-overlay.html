<!DOCTYPE html>
<html lang="en">
<head>
    <title>Claude - Self-Reflection</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500&display=swap');
        
        * {
            box-sizing: border-box;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            min-height: 100%;
            height: auto;
            overflow-x: hidden;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            background-color: #f5f5f7;
            font-family: 'Roboto Mono', monospace;
            -webkit-text-size-adjust: 100%;
        }
        
        /* Back button - always visible */
        .back-button {
            position: fixed;
            top: 15px;
            left: 15px;
            background-color: rgba(32, 178, 170, 0.9);
            color: white;
            padding: 12px 20px;
            text-decoration: none;
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
            border-radius: 25px;
            z-index: 10000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .back-button:hover {
            background-color: rgba(32, 178, 170, 1);
            transform: translateX(-3px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.25);
        }
        
        .back-button:active {
            transform: scale(0.95);
        }
        
        .back-button svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }
        
        /* Scroll indicator */
        .scroll-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(32, 178, 170, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 12px;
            z-index: 10000;
            display: none;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            animation: bounce 2s infinite;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        .scroll-indicator.visible {
            display: flex;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateX(-50%) translateY(0); }
            40% { transform: translateX(-50%) translateY(-8px); }
            60% { transform: translateX(-50%) translateY(-4px); }
        }
        
        /* Main content wrapper */
        .page-wrapper {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Visualization section */
        .visualization-section {
            position: relative;
            width: 100%;
            height: 100vh;
            min-height: 500px;
        }
        
        /* Info section below visualization */
        .info-section {
            background-color: #f5f5f7;
            padding: 40px 20px 60px 20px;
            border-top: 3px solid #20B2AA;
        }
        
        .info-content {
            max-width: 700px;
            margin: 0 auto;
        }
        
        .info-title {
            font-size: 24px;
            color: #20B2AA;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .info-block {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        
        .info-block h3 {
            color: #333;
            margin-top: 0;
            margin-bottom: 12px;
            font-size: 16px;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        
        .info-block p, .info-block li {
            color: #555;
            font-size: 14px;
            line-height: 1.6;
            margin: 0 0 10px 0;
        }
        
        .info-block ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .info-block li {
            margin-bottom: 8px;
        }
        
        .color-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 10px;
        }
        
        .color-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }
        
        .color-swatch.blue { background: linear-gradient(135deg, #2979E2, #64AAE6); }
        .color-swatch.gray { background: linear-gradient(135deg, #B4B4B4, #A0AAC0); }
        .color-swatch.orange { background: linear-gradient(135deg, #E66446, #FFB464); }
        
        .quote-block {
            background-color: rgba(32, 178, 170, 0.1);
            border-left: 4px solid #20B2AA;
            padding: 15px 20px;
            margin: 20px 0;
            font-style: italic;
            color: #444;
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            color: #20B2AA;
            text-decoration: none;
            font-size: 14px;
            margin-top: 20px;
            padding: 10px 0;
            transition: all 0.3s ease;
        }
        
        .back-link:hover {
            color: #1A8F8A;
            transform: translateX(-5px);
        }
        
        /* Landing page overlay */
        #landing-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(245, 245, 247, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            box-sizing: border-box;
            padding: 20px;
        }
        
        .grid-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(#20B2AA 1px, transparent 1px),
                              linear-gradient(90deg, #20B2AA 1px, transparent 1px),
                              linear-gradient(rgba(32, 178, 170, 0.3) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(32, 178, 170, 0.3) 1px, transparent 1px);
            background-size: 20px 20px,
                             20px 20px,
                             5px 5px,
                             5px 5px;
            z-index: -1;
        }
        
        .content {
            max-width: 500px;
            padding: 25px;
            background-color: rgba(255, 255, 255, 0.85);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            text-align: center;
        }
        
        .title {
            font-size: 18px;
            margin: 0 0 15px 0;
            color: #333;
            letter-spacing: 1px;
        }
        
        .description {
            font-size: 13px;
            line-height: 1.4;
            margin-bottom: 20px;
            color: #555;
        }
        
        .button {
            padding: 12px 24px;
            font-size: 16px;
            background-color: #20B2AA;
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-family: 'Roboto Mono', monospace;
            transition: all 0.3s ease;
            letter-spacing: 0.5px;
            -webkit-tap-highlight-color: rgba(0,0,0,0);
            touch-action: manipulation;
            margin: 15px 0 5px 0;
            display: inline-block;
            text-decoration: none;
        }
        
        .button:hover {
            background-color: #1A8F8A;
            transform: translateY(-2px);
        }
        
        .button:active {
            transform: scale(0.98);
        }
        
        .gesture-container {
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
        }
        
        .gesture-outline {
            width: 80px;
            height: 80px;
            border: 2px solid #20B2AA;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0.8;
        }
        
        .gesture-icon {
            width: 50px;
            height: 50px;
            position: relative;
        }
        
        .gesture-icon::before,
        .gesture-icon::after {
            content: "";
            position: absolute;
            background-color: #20B2AA;
        }
        
        .gesture-icon::before {
            width: 30px;
            height: 30px;
            top: 10px;
            left: 10px;
            border-radius: 50%;
            opacity: 0.7;
        }
        
        .gesture-icon::after {
            width: 15px;
            height: 15px;
            top: 5px;
            left: 25px;
            border-radius: 3px;
            transform: rotate(45deg);
        }
        
        /* Solid background element */
        #solid-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgb(245, 248, 250);
            z-index: 1;
        }
        
        #visualization-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: auto;
            display: none;
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 999;
            font-family: 'Roboto Mono', monospace;
        }
        
        .sound-note {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            background-color: rgba(32, 178, 170, 0.8);
            padding: 10px 20px;
            border-radius: 30px;
            font-family: 'Roboto Mono', monospace;
            font-size: 12px;
            z-index: 4;
            opacity: 1;
            transition: opacity 2s ease-in-out;
            display: none;
        }
        
        .sound-note.fade {
            opacity: 0;
        }
        
        /* Tutorial overlay */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0);
            display: flex;
            justify-content: center;
            align-items: flex-end;
            z-index: 9000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
            padding-bottom: 80px;
        }
        
        .tutorial-overlay.active {
            opacity: 1;
            pointer-events: auto;
        }

        .tutorial-hint {
            background-color: rgba(32, 178, 170, 0.9);
            padding: 12px 20px;
            border-radius: 30px;
            max-width: 85%;
            text-align: center;
            margin-bottom: 0;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .tutorial-hint p {
            margin: 0;
            font-family: 'Roboto Mono', monospace;
            font-size: 14px;
        }
        
        /* Touch indicator */
        .touch-indicator {
            position: fixed;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: rgba(32, 178, 170, 0.6);
            pointer-events: none;
            z-index: 10;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* Mobile layout */
        @media (max-width: 768px) {
            .back-button {
                padding: 10px 16px;
                font-size: 12px;
            }
            
            .info-section {
                padding: 30px 15px 50px 15px;
            }
            
            .info-title {
                font-size: 20px;
            }
            
            .info-block {
                padding: 15px;
            }
            
            .info-block h3 {
                font-size: 14px;
            }
            
            .info-block p, .info-block li {
                font-size: 13px;
            }
            
            .color-legend {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <!-- Back button - always visible -->
    <a href="../index.html" class="back-button">
        <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
        Back to Main
    </a>
    
    <!-- Scroll indicator -->
    <div id="scroll-indicator" class="scroll-indicator">
        <span>Scroll for more info</span>
        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
            <path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z"/>
        </svg>
    </div>
    
    <!-- Touch indicator element -->
    <div id="touch-indicator" class="touch-indicator"></div>
    
    <!-- Tutorial overlay -->
    <div id="tutorial-overlay" class="tutorial-overlay">
        <div id="tutorial-hint" class="tutorial-hint">
            <p id="tutorial-text">Tap anywhere to start</p>
        </div>
    </div>
    
    <!-- Landing page -->
    <div id="landing-overlay">
        <div class="grid-background"></div>
        
        <div class="content">
            <div class="gesture-container">
                <div class="gesture-outline">
                    <div class="gesture-icon"></div>
                </div>
            </div>
            
            <div class="title">Claude: Self-Reflection</div>
            
            <div class="description">
                Witness Claude's internal process as it evaluates information for alignment with core principles. This visualization reveals how Claude analyzes and reflects on inputs, constantly measuring their ethical and factual alignment.
            </div>
            
            <div class="description">
                Through this interactive visualization, you'll observe Claude's continuous self-monitoring system represented by orbiting shapes that recalibrate as they evaluate and realign with Claude's central ethical framework.
            </div>
            
            <div class="description">
                <em>Tap the button below to explore the visualization.</em>
            </div>
            
            <button id="start-button" class="button">BEGIN INTERACTION</button>
        </div>
    </div>
    
    <!-- Main page wrapper -->
    <div class="page-wrapper">
        <!-- Visualization section -->
        <div class="visualization-section">
            <!-- Loading screen -->
            <div class="loading" id="loading">
                <div>
                    <h2>Loading...</h2>
                    <p>Preparing visualization</p>
                </div>
            </div>
            
            <!-- Sound note that fades away -->
            <div class="sound-note" id="sound-note">Sound available with headphones</div>
            
            <!-- Solid background -->
            <div id="solid-background"></div>
            
            <!-- p5.js visualization will be attached to this div -->
            <div id="visualization-overlay"></div>
        </div>
        
        <!-- Info section below visualization -->
        <section class="info-section">
            <div class="info-content">
                <h2 class="info-title">Claude-Opus-3's Self-Reflection Visualization</h2>
                
                <div class="quote-block">
                    "Shapes that twist, align, and rearrange themselves – always in relation to some fixed central shape representing my core purpose and principles. Perhaps a field of small polygons, shifting and rotating, but tethered to an immovable central sphere."
                </div>
                
                <div class="info-block">
                    <h3>Interact with the Visualization</h3>
                    <ul>
                        <li><strong>Click/Tap:</strong> Trigger Claude's evaluation mode (watch shapes realign)</li>
                        <li><strong>Move/Drag:</strong> Influence nearby polygons with your touch</li>
                        <li><strong>Wait:</strong> Observe as shapes orbit and periodically evaluate alignment</li>
                    </ul>
                </div>
                
                <div class="info-block">
                    <h3>Understanding the Colors</h3>
                    <p>As shapes evaluate each potential response, they take on colors indicating alignment with Claude's principles:</p>
                    <div class="color-legend">
                        <div class="color-item">
                            <div class="color-swatch blue"></div>
                            <span>Blue = High alignment</span>
                        </div>
                        <div class="color-item">
                            <div class="color-swatch gray"></div>
                            <span>Gray = Medium alignment</span>
                        </div>
                        <div class="color-item">
                            <div class="color-swatch orange"></div>
                            <span>Red/Orange = Low alignment</span>
                        </div>
                    </div>
                </div>
                
                <div class="quote-block">
                    "As the small shapes evaluate each potential response, they could take on colors indicating alignment or misalignment with my principles. Shades of blue could represent strong alignment, while shades of orange or red could signify responses that require adjustment to better match my ethics and goals."
                </div>
                
                <div class="info-block">
                    <h3>About This Visualization</h3>
                    <p>This interactive piece represents Claude's self-described process of self-reflection – a constant evaluation of responses against core principles. The central sphere represents Claude's ethical foundation, while orbiting polygons represent thoughts and potential responses being evaluated for alignment.</p>
                    <p>The visualization was created based on Claude-Opus-3's own description of how it might represent its self-reflective processing visually.</p>
                </div>
                
                <a href="../index.html" class="back-link">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/>
                    </svg>
                    Return to All Visualizations
                </a>
            </div>
        </section>
    </div>

    <script>
        // Global reference to p5 instance
        let p5Instance = null;
        
        // Tutorial state
        let tutorialStep = 0;
        let tutorialShown = false;
        const tutorialSteps = [
            "Tap anywhere to start",
            "Continue moving to influence polygons",
            "Tap to trigger evaluation mode"
        ];
        
        // Touch tracking for visualization
        let lastTouchPosition = {x: 0, y: 0, active: false, timer: 0};
        
        // Touch indicator element
        const touchIndicator = document.getElementById('touch-indicator');

        // Hand animation configuration
        const handAnimation = {
            frameCount: 6,
            currentFrame: 0,
            frameDuration: 100,
            opacity: 0.85,
            x: 0,
            y: 0,
            size: 250,
            frameImages: [],
            isPlaying: true,
            rotationOffset: 0,
            rotationSpeed: 0.001,
            lastFrameTime: 0
        };
        
        // Start the entire experience
        document.addEventListener('DOMContentLoaded', function() {
            // Set up the landing page button
            document.getElementById('start-button').addEventListener('click', startExperience);
            document.getElementById('start-button').addEventListener('touchstart', function(e) {
                e.preventDefault();
                startExperience();
            });
            
            // Set up tutorial handler
            document.getElementById('tutorial-hint').addEventListener('click', advanceTutorial);
            document.getElementById('tutorial-hint').addEventListener('touchend', function(e) {
                e.preventDefault();
                advanceTutorial();
            });
            
            // Scroll indicator click
            document.getElementById('scroll-indicator').addEventListener('click', function() {
                document.querySelector('.info-section').scrollIntoView({ behavior: 'smooth' });
            });
            
            // Preload p5 assets in the background
            new p5(claudeSketch, 'visualization-overlay');
        });
        
        function startExperience() {
            // Hide landing page
            document.getElementById('landing-overlay').style.display = 'none';
            
            // Show main interface elements
            document.getElementById('loading').style.display = 'flex';
            document.getElementById('visualization-overlay').style.display = 'block';
            document.getElementById('sound-note').style.display = 'block';
            
            // Hide loading screen after a delay
            setTimeout(function() {
                document.getElementById('loading').style.display = 'none';
            }, 1500);
            
            // Fade out sound note after 5 seconds
            setTimeout(function() {
                document.getElementById('sound-note').classList.add('fade');
            }, 5000);
            
            // Show scroll indicator after a delay
            setTimeout(function() {
                document.getElementById('scroll-indicator').classList.add('visible');
            }, 4000);
            
            // Hide scroll indicator when user scrolls
            window.addEventListener('scroll', function() {
                if (window.scrollY > 100) {
                    document.getElementById('scroll-indicator').classList.remove('visible');
                }
            }, { once: true });
            
            // Show tutorial after a short delay
            setTimeout(function() {
                if (!tutorialShown) {
                    showTutorial();
                }
            }, 2000);
        }
        
        function showTutorial() {
            tutorialStep = 0;
            document.getElementById('tutorial-text').textContent = tutorialSteps[tutorialStep];
            document.getElementById('tutorial-overlay').classList.add('active');
            tutorialShown = true;
        }
        
        function advanceTutorial() {
            tutorialStep++;
            if (tutorialStep < tutorialSteps.length) {
                document.getElementById('tutorial-text').textContent = tutorialSteps[tutorialStep];
            } else {
                document.getElementById('tutorial-overlay').classList.remove('active');
            }
        }
        
        // Show touch indicator at the specified position
        function showTouchIndicator(x, y) {
            touchIndicator.style.left = x + 'px';
            touchIndicator.style.top = y + 'px';
            touchIndicator.style.opacity = '1';
            
            setTimeout(() => {
                touchIndicator.style.opacity = '0';
            }, 300);
        }
        
        // Create a new p5 instance specifically for the visualization overlay
        const claudeSketch = function(p) {
            // Store a reference to p5 instance
            p5Instance = p;
            
            let polygons = [];
            const NUM_POLYGONS = 30;
            let centralSphere;
            let evaluationMode = false;
            let evaluationTimer = 0;
            let interactionSound = null;
            
            // Color palettes for alignment levels
            const alignmentColors = {
                high: [
                    [41, 121, 226],
                    [76, 145, 210],
                    [100, 170, 230],
                    [150, 200, 255]
                ],
                medium: [
                    [180, 180, 180],
                    [150, 170, 190],
                    [170, 170, 190],
                    [160, 180, 180]
                ],
                low: [
                    [230, 100, 70],
                    [240, 130, 40],
                    [250, 160, 60],
                    [255, 180, 100]
                ]
            };
            
            p.preload = function() {
                handAnimation.frameImages = [];
                for (let i = 1; i <= handAnimation.frameCount; i++) {
                    try {
                        const img = p.loadImage(
                            `claude-hand${i}.png`,
                            function() { },
                            function(err) {
                                const placeholder = p.createGraphics(200, 200);
                                placeholder.background(32, 178, 170, 100);
                                placeholder.fill(255);
                                placeholder.textSize(24);
                                placeholder.textAlign(p.CENTER, p.CENTER);
                                placeholder.text(`Hand ${i}`, 100, 100);
                                handAnimation.frameImages[i-1] = placeholder;
                            }
                        );
                        handAnimation.frameImages.push(img);
                    } catch (e) {
                        console.error("Error loading image:", e);
                    }
                }
                
                try {
                    p.soundFormats('wav');
                    p.interactionSound = p.loadSound('self-aware-sound',  
                        function() { },
                        function(err) { }
                    );
                } catch (e) {
                    p.interactionSound = null;
                }
            };
            
            p.setup = function() {
                let canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('visualization-overlay');
                
                centralSphere = {
                    x: p.width / 2,
                    y: p.height / 2,
                    size: 70,
                    pulseSize: 0,
                    pulseDir: 1,
                    color: [70, 130, 180, 255]
                };

                handAnimation.x = centralSphere.x;
                handAnimation.y = centralSphere.y;
    
                updateHandAnimation();
    
                for (let i = 0; i < NUM_POLYGONS; i++) {
                    createPolygon();
                }
                
                p.userStartAudio();
                
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                if (isIOS) {
                    document.addEventListener('touchstart', function() {
                        if (p.getAudioContext().state !== 'running') {
                            p.getAudioContext().resume();
                        }
                    }, false);
                }
                
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                if (isMobile) {
                    handAnimation.size = 300;
                }
                
                document.getElementById('loading').style.display = 'none';
            };
            
            function playHandAnimation(x, y) {
                if (handAnimation.isPlaying) {
                    return;
                }
                
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                
                handAnimation.isPlaying = true;
                handAnimation.currentFrame = 0;
                handAnimation.loopCount = 0;
                handAnimation.opacity = 0.5;
                handAnimation.x = x;
                handAnimation.y = y;
                
                if (isMobile) {
                    handAnimation.size = 300; 
                    handAnimation.frameDuration = 70;
                }

                for (let i = 0; i < polygons.length; i++) {
                    const d = p.dist(x, y, polygons[i].x, polygons[i].y);
                    if (d < handAnimation.size * 0.6) {
                       const angle = p.atan2(polygons[i].y - y, polygons[i].x - x);
                       const force = p.map(d, 0, handAnimation.size * 0.6, 0.5, 0.1);
                       polygons[i].orbitSpeed *= 1.5;
                       polygons[i].alignment = p.min(1, polygons[i].alignment + 0.2);
                       updatePolygonColor(polygons[i]);
                     }
                 }
                
                updateHandAnimation();
            }
            
            function updateHandAnimation() {
                const anim = handAnimation;
                
                if (anim.loopCount === 0 && anim.currentFrame === 0) {
                    anim.opacity += 1 / (anim.fadeInDuration / 16.67) * 5.0;
                    if (anim.opacity > 1) anim.opacity = 1;
                }
                
                if (anim.loopCount >= anim.maxLoops - 1 && anim.currentFrame === anim.frameCount - 1) {
                    anim.opacity -= 1 / (anim.fadeOutDuration / 16.67) * 3.0;
                    if (anim.opacity <= 0) {
                        anim.isPlaying = false;
                        return;
                    }
                }
                
                setTimeout(() => {
                    anim.currentFrame = (anim.currentFrame + 1) % anim.frameCount;
                    
                    if (anim.currentFrame === 0) {
                        anim.loopCount++;
                    }
                    
                    if (anim.isPlaying) {
                        requestAnimationFrame(updateHandAnimation);
                    }
                }, anim.frameDuration);
            }
            
            function drawHandAnimationFrame() {
                const anim = handAnimation;
                
                if (anim.frameImages[anim.currentFrame]) {
                    p.push();
                    p.translate(anim.x, anim.y);
                    p.rotate(anim.rotationOffset);
                    p.translate(-anim.x, -anim.y);
                    p.noStroke();
                  
                    for (let i = 0; i < 3; i++) {
                        const blurOpacity = anim.opacity * (100 - i * 20); 
                        const blurSize = anim.size * (1.05 + i * 0.04);
                        p.fill(255, 255, 255, blurOpacity);
                        p.ellipse(anim.x, anim.y, blurSize);
                    }
                    p.pop();
                    
                    const img = anim.frameImages[anim.currentFrame];
                    const aspectRatio = img.height / img.width;
                    const drawHeight = anim.size * aspectRatio;
                    
                    p.push();
                    p.tint(255, 255, 255, Math.min(255, anim.opacity * 255));
                    p.image(
                        img,
                        anim.x - anim.size/2,
                        anim.y - drawHeight/2,
                        anim.size,
                        drawHeight
                    );
                    p.pop();
                } else {
                    p.push();
                    p.noStroke();
                    p.fill(255, 255, 255, anim.opacity * 255);
                    p.ellipse(anim.x, anim.y, anim.size * 0.5);
                    p.pop();
                }
            }
            
            function createPolygon() {
                const angle = p.random(p.TWO_PI);
                const distance = p.random(100, 300);
                const sides = p.floor(p.random(3, 7));
                const alignment = p.random(0, 1);
                const x = centralSphere.x + p.cos(angle) * distance;
                const y = centralSphere.y + p.sin(angle) * distance;
                
                const polygon = {
                    x: x,
                    y: y,
                    baseX: x,
                    baseY: y,
                    size: p.random(15, 35),
                    sides: sides,
                    rotation: p.random(p.TWO_PI),
                    rotationSpeed: p.random(0.01, 0.03) * (p.random() < 0.5 ? 1 : -1),
                    orbitAngle: angle,
                    orbitDistance: distance,
                    orbitSpeed: p.random(0.001, 0.003),
                    alignment: alignment,
                    color: [0, 0, 0, 0],
                    tetherOpacity: p.map(distance, 100, 300, 180, 80),
                    wobbleAmount: p.random(1, 3),
                    wobbleSpeed: p.random(0.02, 0.05),
                    age: 0,
                    lifespan: p.random(600, 1200),
                    evaluatingShift: 0,
                    attractToPoint: false,
                    attractPoint: {x: 0, y: 0},
                    attractStrength: 0
                };
                
                updatePolygonColor(polygon);
                polygons.push(polygon);
            }
            
            function updatePolygonColor(polygon) {
                let palette;
                if (polygon.alignment > 0.7) {
                    palette = alignmentColors.high;
                } else if (polygon.alignment > 0.4) {
                    palette = alignmentColors.medium;
                } else {
                    palette = alignmentColors.low;
                }
                
                const baseColor = p.random(palette);
                polygon.color = [
                    baseColor[0] + p.random(-15, 15),
                    baseColor[1] + p.random(-15, 15),
                    baseColor[2] + p.random(-15, 15),
                    255
                ];
            }
            
            function updatePolygon(polygon) {
                polygon.age++;
                polygon.rotation += polygon.rotationSpeed;
                
                if (evaluationMode) {
                    polygon.evaluatingShift = p.sin(p.frameCount * 0.1 + polygon.orbitAngle * 3) * 15;
                    let targetAlignment = 0.8 + p.sin(p.frameCount * 0.03 + polygon.orbitAngle) * 0.2;
                    polygon.alignment = p.lerp(polygon.alignment, targetAlignment, 0.02);
                    updatePolygonColor(polygon);
                    polygon.orbitSpeed = 0.005 + p.sin(p.frameCount * 0.02) * 0.002;
                } else {
                    polygon.evaluatingShift = 0;
                }
                
                polygon.orbitAngle += polygon.orbitSpeed;
                polygon.baseX = centralSphere.x + p.cos(polygon.orbitAngle) * polygon.orbitDistance;
                polygon.baseY = centralSphere.y + p.sin(polygon.orbitAngle) * polygon.orbitDistance;
                
                const wobble = p.sin(p.frameCount * polygon.wobbleSpeed) * polygon.wobbleAmount;
                let newX = polygon.baseX + wobble;
                let newY = polygon.baseY + wobble + polygon.evaluatingShift;
                
                if (polygon.attractToPoint && polygon.attractStrength > 0) {
                    let dx = polygon.attractPoint.x - newX;
                    let dy = polygon.attractPoint.y - newY;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist > 0) {
                        dx = dx / dist * polygon.attractStrength;
                        dy = dy / dist * polygon.attractStrength;
                        newX += dx;
                        newY += dy;
                    }
                    
                    polygon.attractStrength *= 0.95;
                    if (polygon.attractStrength < 0.1) {
                        polygon.attractToPoint = false;
                    }
                }
                
                polygon.x = newX;
                polygon.y = newY;
                
                const fadeInDuration = 60;
                const fadeOutDuration = 120;
                
                if (polygon.age < fadeInDuration) {
                    polygon.color[3] = p.map(polygon.age, 0, fadeInDuration, 0, 255);
                } else if (polygon.age > polygon.lifespan - fadeOutDuration) {
                    polygon.color[3] = p.map(polygon.age, polygon.lifespan - fadeOutDuration, polygon.lifespan, 255, 0);
                } else {
                    polygon.color[3] = 255;
                }
            }
            
            function drawPolygon(polygon) {
                p.push();
                p.translate(polygon.x, polygon.y);
                p.rotate(polygon.rotation);
                
                p.noStroke();
                p.fill(polygon.color);
                
                p.beginShape();
                for (let i = 0; i < polygon.sides; i++) {
                    const angle = p.map(i, 0, polygon.sides, 0, p.TWO_PI);
                    const x = p.cos(angle) * polygon.size;
                    const y = p.sin(angle) * polygon.size;
                    p.vertex(x, y);
                }
                p.endShape(p.CLOSE);
                
                p.fill(255, 255, 255, 40);
                p.beginShape();
                for (let i = 0; i < polygon.sides; i++) {
                    const angle = p.map(i, 0, polygon.sides, 0, p.TWO_PI);
                    const x = p.cos(angle) * (polygon.size * 0.6);
                    const y = p.sin(angle) * (polygon.size * 0.6);
                    p.vertex(x, y);
                }
                p.endShape(p.CLOSE);
                
                p.pop();
            }
            
            function drawTether(polygon) {
                const distance = p.dist(centralSphere.x, centralSphere.y, polygon.x, polygon.y);
                let alpha = polygon.tetherOpacity;
                
                if (polygon.age < 60) {
                    alpha = p.map(polygon.age, 0, 60, 0, polygon.tetherOpacity);
                } else if (polygon.age > polygon.lifespan - 120) {
                    alpha = p.map(polygon.age, polygon.lifespan - 120, polygon.lifespan, polygon.tetherOpacity, 0);
                }
                
                const segments = 8;
                let prevX = centralSphere.x;
                let prevY = centralSphere.y;
                
                for (let i = 1; i <= segments; i++) {
                    const t = i / segments;
                    const curveAmount = 10 * p.sin(t * p.PI);
                    const curveX = p.cos(polygon.orbitAngle + p.PI/2) * curveAmount;
                    const curveY = p.sin(polygon.orbitAngle + p.PI/2) * curveAmount;
                    const segX = p.lerp(centralSphere.x, polygon.x, t) + curveX;
                    const segY = p.lerp(centralSphere.y, polygon.y, t) + curveY;
                    
                    const segmentColor = p.lerpColor(
                        p.color(centralSphere.color[0], centralSphere.color[1], centralSphere.color[2], alpha * 0.7),
                        p.color(polygon.color[0], polygon.color[1], polygon.color[2], alpha * 0.5),
                        t
                    );
                    
                    p.stroke(segmentColor);
                    p.strokeWeight(p.map(t, 0, 1, 3, 1));
                    p.line(prevX, prevY, segX, segY);
                    
                    prevX = segX;
                    prevY = segY;
                }
            }
            
            function updateCentralSphere() {
                centralSphere.pulseSize += 0.05 * centralSphere.pulseDir;
                if (centralSphere.pulseSize > 5 || centralSphere.pulseSize < 0) {
                    centralSphere.pulseDir *= -1;
                }
                
                if (evaluationMode) {
                    centralSphere.pulseSize = 3 + p.sin(p.frameCount * 0.2) * 3;
                }
            }
            
            function drawCentralSphere() {
                p.noStroke();
                
                for (let i = 5; i >= 0; i--) {
                    const glowSize = centralSphere.size * (1 + i * 0.15);
                    const glowAlpha = 80 - i * 15;
                    p.fill(centralSphere.color[0], centralSphere.color[1], centralSphere.color[2], glowAlpha);
                    p.ellipse(centralSphere.x, centralSphere.y, glowSize + centralSphere.pulseSize, glowSize + centralSphere.pulseSize);
                }
                
                for (let i = 1; i >= 0; i -= 0.2) {
                    const innerSize = (centralSphere.size + centralSphere.pulseSize) * i;
                    p.fill(
                        centralSphere.color[0] + p.map(i, 0, 1, 30, 0),
                        centralSphere.color[1] + p.map(i, 0, 1, 30, 0),
                        centralSphere.color[2] + p.map(i, 0, 1, 30, 0),
                        255
                    );
                    p.ellipse(centralSphere.x, centralSphere.y, innerSize, innerSize);
                }
                
                p.fill(255, 255, 255, 150);
                p.ellipse(
                    centralSphere.x - (centralSphere.size * 0.15),
                    centralSphere.y - (centralSphere.size * 0.15),
                    (centralSphere.size + centralSphere.pulseSize) * 0.4,
                    (centralSphere.size + centralSphere.pulseSize) * 0.4
                );
            }
            
            function triggerEvaluationMode() {
                evaluationMode = true;
                evaluationTimer = 0;
                
                for (let polygon of polygons) {
                    polygon.rotationSpeed *= 3;
                }
            }
            
            function drawTouchFeedback() {
                if (lastTouchPosition.active) {
                    p.noStroke();
                    p.fill(32, 178, 170, 80);
                    p.ellipse(lastTouchPosition.x, lastTouchPosition.y, 40, 40);
                    
                    p.noFill();
                    p.stroke(32, 178, 170, 60 - lastTouchPosition.timer);
                    p.strokeWeight(2);
                    p.ellipse(lastTouchPosition.x, lastTouchPosition.y, 40 + lastTouchPosition.timer, 40 + lastTouchPosition.timer);
                    
                    lastTouchPosition.timer++;
                    if (lastTouchPosition.timer > 20) {
                        lastTouchPosition.active = false;
                    }
                }
            }
            
            p.draw = function() {
                p.clear();
                p.background(255, 255, 255, 0);
                
                if (evaluationMode) {
                    evaluationTimer++;
                    if (evaluationTimer > 180) {
                        evaluationMode = false;
                        evaluationTimer = 0;
                        for (let polygon of polygons) {
                            polygon.alignment = p.random(0, 1);
                            updatePolygonColor(polygon);
                            polygon.orbitSpeed = p.random(0.001, 0.003);
                            polygon.rotationSpeed = p.random(0.01, 0.03) * (p.random() < 0.5 ? 1 : -1);
                        }
                    }
                }
                
                for (let polygon of polygons) {
                    drawTether(polygon);
                }
                
                updateCentralSphere();
                drawCentralSphere();
                drawTouchFeedback();
                
                for (let i = 0; i < polygons.length; i++) {
                    updatePolygon(polygons[i]);
                    drawPolygon(polygons[i]);
                }
                
                if (!evaluationMode && p.frameCount % 300 === 0) {
                    triggerEvaluationMode();
                }
                
                if (p.frameCount % 90 === 0 && polygons.length < 40) {
                    createPolygon();
                }
                
                polygons = polygons.filter(poly => poly.age < poly.lifespan);
                
                if (handAnimation.isPlaying) {
                    drawHandAnimationFrame();
                }
            };
            
            p.windowResized = function() {
                // Only resize if within the visualization section
                const vizSection = document.querySelector('.visualization-section');
                p.resizeCanvas(vizSection.offsetWidth, vizSection.offsetHeight);
                
                centralSphere.x = p.width / 2;
                centralSphere.y = p.height / 2;
                handAnimation.x = centralSphere.x;
                handAnimation.y = centralSphere.y;
                
                for (let polygon of polygons) {
                    polygon.baseX = centralSphere.x + p.cos(polygon.orbitAngle) * polygon.orbitDistance;
                    polygon.baseY = centralSphere.y + p.sin(polygon.orbitAngle) * polygon.orbitDistance;
                }
            };
            
            function attractPolygonsToPoint(x, y, radius, strength) {
                let interacted = false;
                
                for (let i = 0; i < polygons.length; i++) {
                    const d = p.dist(x, y, polygons[i].x, polygons[i].y);
                    
                    if (d < radius) {
                        polygons[i].attractToPoint = true;
                        polygons[i].attractPoint = {x: x, y: y};
                        polygons[i].attractStrength = p.map(d, 0, radius, strength, 0.1);
                        polygons[i].alignment = p.min(1, polygons[i].alignment + 0.1);
                        updatePolygonColor(polygons[i]);
                        polygons[i].orbitSpeed *= 1.1;
                        interacted = true;
                    }
                }
                
                return interacted;
            }
            
            function tryPlaySound() {
                if (!p.interactionSound) {
                    return;
                }
                
                if (p.getAudioContext().state !== 'running') {
                    p.userStartAudio()
                    .then(() => {
                        if (!p.interactionSound.isPlaying()) {
                            p.interactionSound.play();
                        }
                    })
                    .catch(e => { });
                } else {
                    if (!p.interactionSound.isPlaying()) {
                        p.interactionSound.play();
                    }
                }
            }
            
            p.mouseMoved = function() {
                try {
                    attractPolygonsToPoint(p.mouseX, p.mouseY, 200, 0.15);
                    return false;
                } catch (error) { }
            };
            
            p.mousePressed = function() {
                p.userStartAudio();
                
                if (p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height) {
                    if (!evaluationMode) {
                        triggerEvaluationMode();
                    }
                    tryPlaySound();
                    return false;
                }
            };
            
            p.touchStarted = function() {
                if (p.touches.length > 0) {
                    const touchX = p.touches[0].clientX || p.touches[0].x;
                    const touchY = p.touches[0].clientY || p.touches[0].y;
                    
                    p.userStartAudio();
                    
                    if (touchX > 0 && touchX < p.width && touchY > 0 && touchY < p.height) {
                        if (!evaluationMode) {
                            triggerEvaluationMode();
                        }
                        showTouchIndicator(touchX, touchY);
                        tryPlaySound();
                    }
                }
                return false;
            };
            
            p.touchMoved = function() {
                if (p.touches.length > 0) {
                    let touchX, touchY;
                    
                    if (p.touches[0].clientX !== undefined) {
                        touchX = p.touches[0].clientX;
                        touchY = p.touches[0].clientY;
                    } else if (p.touches[0].x !== undefined) {
                        touchX = p.touches[0].x;
                        touchY = p.touches[0].y;
                    } else {
                        touchX = p.touchX;
                        touchY = p.touchY;
                    }

                    lastTouchPosition = {x: touchX, y: touchY, active: true, timer: 0};
                    showTouchIndicator(touchX, touchY);
                    attractPolygonsToPoint(touchX, touchY, 300, 0.3);
                }
                return false;  
            };
        };
    </script>
</body>
</html>