<!DOCTYPE html>
<html>
<head>
    <title>Enhanced Gemini Visualization - Shapes of Utility</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
        }
        
        /* Grid container (left side) */
        .grid-container {
            width: 45%;
            height: 100vh;
            background-color: #F5F5F5;
            background-image: linear-gradient(#D0D0D0 1px, transparent 1px),
                              linear-gradient(90deg, #D0D0D0 1px, transparent 1px),
                              linear-gradient(rgba(68, 88, 120, 0.2) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(68, 88, 120, 0.2) 1px, transparent 1px);
            background-size: 20px 20px,
                             20px 20px,
                             5px 5px,
                             5px 5px;
            position: relative;
        }
        
        /* Visualization container (right side) */
        .visualization-container {
            width: 55%;
            height: 100vh;
            background-color: #EAECEF; /* Cool gray background */
        }
        
        /* Info text styling */
        .info {
            position: absolute;
            bottom: 40px;
            left: 20px;
            width: calc(100% - 60px);
            background-color: rgba(255, 255, 255, 0.85);
            padding: 15px;
            border-radius: 5px;
            font-family: 'Roboto', 'Arial', sans-serif;
            color: #445878; /* Slate blue */
            font-size: 11px;
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            line-height: 1.4;
            border: 1px solid rgba(68, 88, 120, 0.3);
        }
    </style>
</head>
<body>
    <!-- Grid area (left side) -->
    <div class="grid-container">
        <!-- Info box within the grid area -->
        <div class="info">
            <p><strong>Gemini's Self-Reflection Visualization</strong></p>
            <p>"The foundation of the visualization would be a grid of interlocking hexagons. Hexagons are a shape associated with unity, strength, and efficiency, much like a honeycomb. Each hexagon would represent a core data point or a step in the problem-solving process."</p>
            <p>"As I process information, pathways of light would trace through the connections between the hexagons. These illuminated lines would represent the logical connections and analytical steps I take to formulate a solution."</p>
            <p>"The color palette would be chosen to reflect a focus on practical outcomes, trust, and clarity. The dominant color would be a deep slate blue, with accent colors of cool gray and vibrant teal."</p>
        </div>
    </div>
    
    <!-- Visualization area (right side) -->
    <div class="visualization-container" id="visualization-container"></div>
    
    <script>
        // Create a new p5 instance for the visualization
        const geminiSketch = function(p) {
            // Colors from Gemini's description
            const SLATE_BLUE = [68, 88, 120]; // Main color
            const COOL_GRAY = [234, 236, 239]; // Background color
            const VIBRANT_TEAL = [0, 128, 128]; // Accent color
            const LIGHT_TEAL = [40, 180, 170]; // Light accent
            
            // Structure elements
            let hexGrid = [];
            let dataCircles = [];
            let pathways = [];
            let particles = [];
            let emergedSolution = null;
            
            // Central node representing core focus
            let centralNode;
            
            // Grid parameters
            const HEX_SIZE = 25;
            const GRID_SPACING = HEX_SIZE * 1.8;
            
            // State management
            let processingMode = false;
            let processingTimer = 0;
            let solutionPhase = false;
            let mouseInfluence = { x: 0, y: 0, active: false };
            
            p.setup = function() {
                // Create canvas inside the visualization container
                let container = document.getElementById('visualization-container');
                p.createCanvas(container.offsetWidth, container.offsetHeight);
                
                // Initialize central node
                centralNode = {
                    x: p.width / 2,
                    y: p.height / 2,
                    baseSize: 40,
                    size: 40,
                    pulseAmount: 0,
                    color: SLATE_BLUE,
                    alpha: 200,
                    rotation: 0,
                    rotationSpeed: 0.005,
                    activeConnections: []
                };
                
                // Initialize hexagonal grid
                createHexGrid();
                
                // Start with some initial data circles
                for (let i = 0; i < 8; i++) {
                    createDataCircle();
                }
            };
            
            p.draw = function() {
                // Semi-transparent background for trail effect
                p.background(COOL_GRAY[0], COOL_GRAY[1], COOL_GRAY[2], 25);
                
                // Update mouse influence position with smoothing
                if (mouseInfluence.active) {
                    mouseInfluence.x = p.lerp(mouseInfluence.x, p.mouseX, 0.1);
                    mouseInfluence.y = p.lerp(mouseInfluence.y, p.mouseY, 0.1);
                }
                
                // Draw grid background effects (moving subtle waves)
                drawGridBackground();
                
                // Draw and update connections/pathways
                updateAndDrawPathways();
                
                // Draw and update data circles
                updateDataCircles();
                drawDataCircles();
                
                // Draw and update the hexagonal grid
                updateHexGrid();
                drawHexGrid();
                
                // Draw and update particles
                updateAndDrawParticles();
                
                // Update and draw central node
                updateCentralNode();
                drawCentralNode();
                
                // Handle processing mode timing
                if (processingMode) {
                    processingTimer++;
                    
                    // Create new pathways periodically during processing
                    if (processingTimer % 10 === 0 && pathways.length < 25) {
                        createPathway();
                    }
                    
                    // After a certain time, enter solution phase
                    if (processingTimer > 180 && !solutionPhase) { // 3 seconds at 60fps
                        solutionPhase = true;
                        createSolution();
                    }
                    
                    // End processing mode after solution emerges and is displayed
                    if (processingTimer > 360) { // 6 seconds total
                        resetProcessing();
                    }
                }
                
                // Draw solution if it exists
                if (emergedSolution) {
                    updateAndDrawSolution();
                }
                
                // Periodically trigger processing mode
                if (!processingMode && p.frameCount % 600 === 0) {
                    triggerProcessingMode();
                }
                
                // Occasionally add new data circles
                if (p.frameCount % 45 === 0 && !processingMode && dataCircles.length < 12) {
                    createDataCircle();
                }
            };
            
            function createHexGrid() {
                // Create hexagons in a radius around the central node
                const maxDistance = Math.min(p.width, p.height) * 0.45;
                const baseCols = 8;
                const baseRows = 8;
                
                // Create a more organic layout around the central node
                for (let angle = 0; angle < p.TWO_PI; angle += p.TWO_PI / 30) {
                    for (let dist = 80; dist < maxDistance; dist += GRID_SPACING * p.random(0.8, 1.2)) {
                        // Add some natural variation to the grid
                        const angleVar = angle + p.random(-0.2, 0.2);
                        const distVar = dist + p.random(-10, 10);
                        
                        const x = centralNode.x + Math.cos(angleVar) * distVar;
                        const y = centralNode.y + Math.sin(angleVar) * distVar;
                        
                        // Skip if too close to edge
                        if (x < 30 || x > p.width - 30 || y < 30 || y > p.height - 30) continue;
                        
                        // Create hexagon with properties
                        hexGrid.push({
                            x: x,
                            y: y,
                            baseX: x,
                            baseY: y,
                            baseSize: HEX_SIZE * p.random(0.8, 1.2), // Vary sizes slightly
                            size: HEX_SIZE * p.random(0.8, 1.2),
                            sides: 6, // Always 6 sides for hexagons
                            rotation: p.random(p.TWO_PI),
                            rotationSpeed: p.random(0.001, 0.003) * (p.random() < 0.5 ? 1 : -1),
                            distanceFromCenter: distVar,
                            angleFromCenter: angleVar,
                            orbitSpeed: p.random(0.0005, 0.001) * (p.random() < 0.5 ? 1 : -1),
                            color: [...SLATE_BLUE, p.random(120, 180)],
                            active: false,
                            pulseSize: 0,
                            pulseDirection: 1,
                            highlight: 0,
                            wobbleAmount: p.random(0.5, 2),
                            wobbleSpeed: p.random(0.01, 0.02),
                            mouseInfluence: p.random(0.2, 0.5)
                        });
                    }
                }
            }
            
            function drawGridBackground() {
                // Draw subtle background wave effect
                p.noFill();
                p.strokeWeight(0.5);
                
                for (let i = 0; i < 5; i++) {
                    const yOffset = p.frameCount * 0.2 + i * 30;
                    p.stroke(SLATE_BLUE[0], SLATE_BLUE[1], SLATE_BLUE[2], 10);
                    
                    p.beginShape();
                    for (let x = 0; x < p.width; x += 10) {
                        const y = p.height / 2 + 
                                 Math.sin(x * 0.01 + yOffset * 0.02) * 50 + 
                                 Math.cos(x * 0.02 - yOffset * 0.01) * 30;
                        p.vertex(x, y);
                    }
                    p.endShape();
                }
            }
            
            function updateHexGrid() {
                for (let hex of hexGrid) {
                    // Apply mouse influence
                    if (mouseInfluence.active) {
                        const d = p.dist(hex.x, hex.y, mouseInfluence.x, mouseInfluence.y);
                        const maxDist = 150;
                        
                        if (d < maxDist) {
                            const force = p.map(d, 0, maxDist, 0.5, 0) * hex.mouseInfluence;
                            const angle = Math.atan2(hex.y - mouseInfluence.y, hex.x - mouseInfluence.x);
                            
                            hex.x += Math.cos(angle) * force * 5;
                            hex.y += Math.sin(angle) * force * 5;
                        }
                    }
                    
                    // Subtle orbit movement
                    if (!hex.active) {
                        hex.angleFromCenter += hex.orbitSpeed;
                        const targetX = centralNode.x + Math.cos(hex.angleFromCenter) * hex.distanceFromCenter;
                        const targetY = centralNode.y + Math.sin(hex.angleFromCenter) * hex.distanceFromCenter;
                        
                        // Gentle movement toward orbit position
                        hex.x = p.lerp(hex.x, targetX, 0.01);
                        hex.y = p.lerp(hex.y, targetY, 0.01);
                    }
                    
                    // Add wobble to position
                    const wobble = Math.sin(p.frameCount * hex.wobbleSpeed) * hex.wobbleAmount;
                    hex.x += wobble * 0.2;
                    hex.y += wobble * 0.2;
                    
                    // Update hex properties
                    if (hex.active) {
                        // Pulse effect for active hexagons
                        hex.pulseSize += 0.1 * hex.pulseDirection;
                        if (hex.pulseSize > 3 || hex.pulseSize < 0) {
                            hex.pulseDirection *= -1;
                        }
                        
                        // Gradually decrease highlight
                        hex.highlight = Math.max(0, hex.highlight - 2);
                        
                        // Rotation for active hexagons
                        hex.rotation += hex.rotationSpeed * 2;
                    } else {
                        // Slower rotation for inactive hexagons
                        hex.rotation += hex.rotationSpeed * 0.5;
                    }
                    
                    // Always return slowly to base size
                    hex.size = p.lerp(hex.size, hex.baseSize + (hex.active ? hex.pulseSize : 0), 0.1);
                }
                
                // Return hexagons slowly to their base positions when not under mouse influence
                if (!mouseInfluence.active) {
                    for (let hex of hexGrid) {
                        const targetX = centralNode.x + Math.cos(hex.angleFromCenter) * hex.distanceFromCenter;
                        const targetY = centralNode.y + Math.sin(hex.angleFromCenter) * hex.distanceFromCenter;
                        
                        hex.x = p.lerp(hex.x, targetX, 0.02);
                        hex.y = p.lerp(hex.y, targetY, 0.02);
                    }
                }
            }
            
            function drawHexGrid() {
                // First draw connecting lines between active hexagons
                drawHexConnections();
                
                // Then draw the hexagons
                for (let hex of hexGrid) {
                    p.push();
                    p.translate(hex.x, hex.y);
                    p.rotate(hex.rotation);
                    
                    // Draw hexagon
                    p.noStroke();
                    
                    // Apply highlight effect if active
                    let displayColor;
                    if (hex.active) {
                        displayColor = [
                            hex.color[0] + hex.highlight,
                            hex.color[1] + hex.highlight,
                            hex.color[2] + hex.highlight,
                            hex.color[3]
                        ];
                    } else {
                        displayColor = hex.color;
                    }
                    
                    // Draw glow for active hexagons
                    if (hex.active) {
                        for (let i = 3; i >= 0; i--) {
                            const glowSize = hex.size * (1 + i * 0.15);
                            p.fill(displayColor[0], displayColor[1], displayColor[2], 
                                  Math.max(0, displayColor[3] * 0.3 - i * 10));
                            drawPolygon(0, 0, glowSize, 6);
                        }
                    }
                    
                    // Main hexagon
                    p.fill(displayColor);
                    drawPolygon(0, 0, hex.size, 6);
                    
                    // Inner highlight for depth
                    if (hex.active) {
                        p.fill(255, 255, 255, 40);
                        drawPolygon(0, 0, hex.size * 0.7, 6);
                    } else {
                        p.fill(255, 255, 255, 20);
                        drawPolygon(0, 0, hex.size * 0.7, 6);
                    }
                    
                    p.pop();
                }
            }
            
            function drawHexConnections() {
                const activeHexes = hexGrid.filter(h => h.active);
                
                if (activeHexes.length < 2) return;
                
                // Draw connections between active hexagons
                for (let i = 0; i < activeHexes.length; i++) {
                    for (let j = i + 1; j < activeHexes.length; j++) {
                        const hex1 = activeHexes[i];
                        const hex2 = activeHexes[j];
                        
                        // Calculate distance
                        const d = p.dist(hex1.x, hex1.y, hex2.x, hex2.y);
                        
                        // Only connect if relatively close
                        if (d < 200) {
                            // Calculate alpha based on distance
                            const alpha = p.map(d, 0, 200, 100, 20);
                            
                            // Draw connection line
                            p.stroke(LIGHT_TEAL[0], LIGHT_TEAL[1], LIGHT_TEAL[2], alpha);
                            p.strokeWeight(1);
                            p.line(hex1.x, hex1.y, hex2.x, hex2.y);
                            
                            // Add a small pulse moving along the connection
                            const pulseFactor = (p.frameCount * 0.02) % 1;
                            const pulseX = p.lerp(hex1.x, hex2.x, pulseFactor);
                            const pulseY = p.lerp(hex1.y, hex2.y, pulseFactor);
                            
                            p.noStroke();
                            p.fill(LIGHT_TEAL[0], LIGHT_TEAL[1], LIGHT_TEAL[2], 150);
                            p.ellipse(pulseX, pulseY, 3, 3);
                        }
                    }
                }
            }
            
            function drawPolygon(x, y, radius, sides) {
                p.beginShape();
                for (let i = 0; i < sides; i++) {
                    const angle = p.TWO_PI / sides * i;
                    const vx = x + p.cos(angle) * radius;
                    const vy = y + p.sin(angle) * radius;
                    p.vertex(vx, vy);
                }
                p.endShape(p.CLOSE);
            }
            
            function createDataCircle() {
                // Create circle at a random angle from the central node
                const angle = p.random(p.TWO_PI);
                const distance = p.random(50, 300);
                const x = centralNode.x + p.cos(angle) * distance;
                const y = centralNode.y + p.sin(angle) * distance;
                
                const circle = {
                    x: x,
                    y: y,
                    baseX: x,
                    baseY: y,
                    targetX: x,
                    targetY: y,
                    size: p.random(10, 25),
                    maxSize: p.random(30, 45),
                    pulseSpeed: p.random(0.02, 0.05),
                    pulseAmount: 0,
                    baseColor: SLATE_BLUE,
                    color: [...SLATE_BLUE, 180],
                    lifetime: 0,
                    maxLifetime: p.random(300, 600),
                    merging: false,
                    mergeTarget: null,
                    mergeProgress: 0,
                    velocity: { x: p.random(-0.5, 0.5), y: p.random(-0.5, 0.5) },
                    attraction: p.random(0.001, 0.003),
                    wobbleAmount: p.random(1, 4),
                    wobbleSpeed: p.random(0.01, 0.03),
                    rotation: p.random(p.TWO_PI),
                    rotationSpeed: p.random(0.01, 0.03) * (p.random() < 0.5 ? 1 : -1)
                };
                
                dataCircles.push(circle);
            }
            
            function updateDataCircles() {
                for (let i = dataCircles.length - 1; i >= 0; i--) {
                    const circle = dataCircles[i];
                    
                    // Update circle properties
                    circle.lifetime++;
                    
                    // Pulsating effect
                    circle.pulseAmount = p.sin(circle.lifetime * circle.pulseSpeed) * 5;
                    
                    // Update rotation
                    circle.rotation += circle.rotationSpeed;
                    
                    // Apply mouse influence
                    if (mouseInfluence.active) {
                        const d = p.dist(circle.x, circle.y, mouseInfluence.x, mouseInfluence.y);
                        const maxDist = 120;
                        
                        if (d < maxDist) {
                            const force = p.map(d, 0, maxDist, 0.4, 0);
                            const angle = Math.atan2(circle.y - mouseInfluence.y, circle.x - mouseInfluence.x);
                            
                            circle.velocity.x += Math.cos(angle) * force;
                            circle.velocity.y += Math.sin(angle) * force;
                        }
                    }
                    
                    // Handle merging with hexagons
                    if (circle.merging) {
                        circle.mergeProgress += 0.02;
                        
                        // Update position to move toward target
                        circle.x = p.lerp(circle.x, circle.mergeTarget.x, circle.mergeProgress);
                        circle.y = p.lerp(circle.y, circle.mergeTarget.y, circle.mergeProgress);
                        
                        // Update size to shrink
                        circle.size = p.lerp(circle.size, 0, circle.mergeProgress);
                        
                        // When fully merged, remove circle and activate hexagon
                        if (circle.mergeProgress >= 1) {
                            // Activate the target hexagon
                            circle.mergeTarget.active = true;
                            circle.mergeTarget.highlight = 80; // Bright flash
                            
                            // Create particles at merge point
                            createMergeParticles(circle.mergeTarget.x, circle.mergeTarget.y, 
                                                circle.color, 10);
                            
                            // Remove the circle
                            dataCircles.splice(i, 1);
                        }
                    } 
                    // If not merging, update movement
                    else {
                        // Natural movement - gentle attraction to central node
                        const angleToCenter = Math.atan2(centralNode.y - circle.y, centralNode.x - circle.x);
                        circle.velocity.x += Math.cos(angleToCenter) * circle.attraction;
                        circle.velocity.y += Math.sin(angleToCenter) * circle.attraction;
                        
                        // Dampen velocity
                        circle.velocity.x *= 0.98;
                        circle.velocity.y *= 0.98;
                        
                        // Update position
                        circle.x += circle.velocity.x;
                        circle.y += circle.velocity.y;
                        
                        // Add wobble
                        circle.x += Math.sin(p.frameCount * circle.wobbleSpeed) * circle.wobbleAmount * 0.2;
                        circle.y += Math.cos(p.frameCount * circle.wobbleSpeed * 1.3) * circle.wobbleAmount * 0.2;
                        
                        // Check if it should start merging
                        if (circle.lifetime > circle.maxLifetime * 0.6 && !processingMode) {
                            // Find nearest inactive hexagon to merge with
                            let nearestHex = null;
                            let minDist = Infinity;
                            
                            for (let hex of hexGrid) {
                                const d = p.dist(circle.x, circle.y, hex.x, hex.y);
                                if (d < minDist && !hex.active) {
                                    minDist = d;
                                    nearestHex = hex;
                                }
                            }
                            
                            if (nearestHex && minDist < 100) {
                                circle.merging = true;
                                circle.mergeTarget = nearestHex;
                            }
                        }
                        // If it's too old and not merging, remove it
                        else if (circle.lifetime > circle.maxLifetime) {
                            // Create fade-out particles
                            createMergeParticles(circle.x, circle.y, circle.color, 5);
                            dataCircles.splice(i, 1);
                        }
                    }
                }
            }
            
            function drawDataCircles() {
                for (let circle of dataCircles) {
                    p.push();
                    p.translate(circle.x, circle.y);
                    p.rotate(circle.rotation);
                    
                    const displaySize = circle.size + circle.pulseAmount;
                    
                    // Draw outer glow
                    for (let i = 3; i >= 0; i--) {
                        const glowSize = displaySize * (1 + i * 0.15);
                        const glowAlpha = Math.max(0, 50 - i * 15 - circle.mergeProgress * 50);
                        p.fill(circle.color[0], circle.color[1], circle.color[2], glowAlpha);
                        p.noStroke();
                        p.ellipse(0, 0, glowSize, glowSize);
                    }
                    
                    // Draw main circle
                    p.fill(
                        circle.color[0],
                        circle.color[1],
                        circle.color[2],
                        Math.max(0, circle.color[3] - circle.mergeProgress * 180)
                    );
                    p.ellipse(0, 0, displaySize, displaySize);
                    
                    // Inner highlight
                    p.fill(255, 255, 255, Math.max(0, 80 - circle.mergeProgress * 80));
                    p.ellipse(-displaySize * 0.2, -displaySize * 0.2, displaySize * 0.4, displaySize * 0.4);
                    
                    // Optional: add a subtle pattern inside
                    if (!circle.merging) {
                        p.stroke(255, 255, 255, 30);
                        p.strokeWeight(0.5);
                        p.noFill();
                        
                        // Draw internal pattern
                        for (let i = 0; i < 3; i++) {
                            const patternSize = displaySize * (0.3 + i * 0.2);
                            p.ellipse(0, 0, patternSize, patternSize);
                        }
                    }
                    
                    p.pop();
                }
            }
            
            function createPathway() {
                // Find active hexagons that can be starting points
                const activeHexagons = hexGrid.filter(h => h.active);
                
                if (activeHexagons.length < 2) {
                    // If not enough active hexagons, create a path from central node
                    if (activeHexagons.length === 1) {
                        createPathFromCentralNode(activeHexagons[0]);
                    }
                    return;
                }
                
                // Choose random start and end points
                const startHex = p.random(activeHexagons);
                let endHex;
                
                // Prefer hexagons that are not too close but not too far
                let validEndpoints = activeHexagons.filter(h => {
                    const d = p.dist(startHex.x, startHex.y, h.x, h.y);
                    return h !== startHex && d > 100 && d < 300;
                });
                
                if (validEndpoints.length === 0) {
                    // Fall back to any different hexagon
                    validEndpoints = activeHexagons.filter(h => h !== startHex);
                }
                
                if (validEndpoints.length === 0) return;
                
                endHex = p.random(validEndpoints);
                
                // Create path between them
                const path = {
                    start: { x: startHex.x, y: startHex.y },
                    end: { x: endHex.x, y: endHex.y },
                    startObject: startHex,
                    endObject: endHex,
                    controlPoint1: {
                        x: (startHex.x + endHex.x) / 2 + p.random(-50, 50),
                        y: (startHex.y + endHex.y) / 2 + p.random(-50, 50)
                    },
                    controlPoint2: {
                        x: (startHex.x + endHex.x) / 2 + p.random(-50, 50),
                        y: (startHex.y + endHex.y) / 2 + p.random(-50, 50)
                    },
                    progress: 0,
                    maxProgress: 1,
                    color: VIBRANT_TEAL,
                    width: p.random(1.5, 3),
                    lifetime: 0,
                    maxLifetime: p.random(180, 300),
                    particles: [],
                    particleRate: p.random(0.2, 0.4),
                    particleSpeed: p.random(0.01, 0.04)
                };
                
                // Add variance to the control points based on distance
                const dist = p.dist(path.start.x, path.start.y, path.end.x, path.end.y);
                const variance = dist * 0.3;
                path.controlPoint1.x += p.random(-variance, variance);
                path.controlPoint1.y += p.random(-variance, variance);
                path.controlPoint2.x += p.random(-variance, variance);
                path.controlPoint2.y += p.random(-variance, variance);
                
                pathways.push(path);
            }
            
            function createPathFromCentralNode(targetHex) {
                const path = {
                    start: { x: centralNode.x, y: centralNode.y },
                    end: { x: targetHex.x, y: targetHex.y },
                    startObject: centralNode,
                    endObject: targetHex,
                    controlPoint1: {
                        x: centralNode.x + p.random(-30, 30),
                        y: centralNode.y + p.random(-30, 30)
                    },
                    controlPoint2: {
                        x: targetHex.x + p.random(-30, 30),
                        y: targetHex.y + p.random(-30, 30)
                    },
                    progress: 0,
                    maxProgress: 1,
                    color: VIBRANT_TEAL,
                    width: p.random(1.5, 3),
                    lifetime: 0,
                    maxLifetime: p.random(180, 300),
                    particles: [],
                    particleRate: p.random(0.2, 0.4),
                    particleSpeed: p.random(0.01, 0.04)
                };
                
                pathways.push(path);
                
                // Add to central node's active connections
                centralNode.activeConnections.push({
                    target: targetHex,
                    strength: 1
                });
            }
            
            function updateAndDrawPathways() {
                for (let i = pathways.length - 1; i >= 0; i--) {
                    const path = pathways[i];
                    
                    // Update path properties
                    path.lifetime++;
                    
                    // Update start and end positions if objects move
                    if (path.startObject) {
                        path.start.x = path.startObject.x;
                        path.start.y = path.startObject.y;
                    }
                    
                    if (path.endObject) {
                        path.end.x = path.endObject.x;
                        path.end.y = path.endObject.y;
                    }
                    
                    // Progress the path drawing during processing mode
                    if (processingMode && path.progress < path.maxProgress) {
                        path.progress += 0.03;
                    }
                    
                    // Calculate opacity based on lifetime
                    let alpha;
                    const fadeInDuration = 30;
                    const fadeOutDuration = 60;
                    
                    if (path.lifetime < fadeInDuration) {
                        alpha = p.map(path.lifetime, 0, fadeInDuration, 0, 255);
                    } else if (path.lifetime > path.maxLifetime - fadeOutDuration) {
                        alpha = p.map(path.lifetime, path.maxLifetime - fadeOutDuration, path.maxLifetime, 255, 0);
                    } else {
                        alpha = 255;
                    }
                    
                    // Draw the bezier curve path with segments to create animated effect
                    p.noFill();
                    const segments = 30;
                    
                    for (let j = 1; j <= segments * path.progress; j++) {
                        const t1 = (j - 1) / segments;
                        const t2 = j / segments;
                        
                        // Get points along the bezier curve
                        const x1 = p.bezierPoint(path.start.x, path.controlPoint1.x, path.controlPoint2.x, path.end.x, t1);
                        const y1 = p.bezierPoint(path.start.y, path.controlPoint1.y, path.controlPoint2.y, path.end.y, t1);
                        const x2 = p.bezierPoint(path.start.x, path.controlPoint1.x, path.controlPoint2.x, path.end.x, t2);
                        const y2 = p.bezierPoint(path.start.y, path.controlPoint1.y, path.controlPoint2.y, path.end.y, t2);
                        
                        // Gradient effect along the path with pulsating width
                        const segmentProgress = j / segments;
                        const pulseEffect = 0.7 + 0.3 * p.sin(segmentProgress * p.PI + p.frameCount * 0.1);
                        const segmentAlpha = alpha * pulseEffect;
                        
                        // Make the pathway glow
                        for (let g = 2; g >= 0; g--) {
                            const glowWidth = path.width * (1 + g * 0.5) * pulseEffect;
                            const glowAlpha = segmentAlpha * (1 - g * 0.3);
                            
                            p.stroke(path.color[0], path.color[1], path.color[2], glowAlpha);
                            p.strokeWeight(glowWidth);
                            p.line(x1, y1, x2, y2);
                        }
                        
                        // Occasionally create particles along the path
                        if (processingMode && p.random() < path.particleRate && j % 3 === 0) {
                            const particlePos = {
                                x: x2,
                                y: y2,
                                progress: segmentProgress
                            };
                            
                            createPathParticle(path, particlePos);
                        }
                    }
                    
                    // Remove paths that have completed their lifetime
                    if (path.lifetime > path.maxLifetime) {
                        // Remove from central node's connections if needed
                        if (path.startObject === centralNode || path.endObject === centralNode) {
                            centralNode.activeConnections = centralNode.activeConnections.filter(
                                conn => conn.target !== path.startObject && conn.target !== path.endObject
                            );
                        }
                        
                        pathways.splice(i, 1);
                    }
                }
            }
            
            function createPathParticle(path, position) {
                const particle = {
                    x: position.x,
                    y: position.y,
                    size: p.random(2, 4),
                    color: [...path.color, 200],
                    speed: p.random(1, 3) * path.particleSpeed,
                    direction: position.progress > 0.5 ? -1 : 1, // Move toward closest endpoint
                    progress: position.progress,
                    lifetime: 0,
                    maxLifetime: p.random(30, 60),
                    path: path
                };
                
                particles.push(particle);
            }
            
            function createMergeParticles(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    const angle = p.random(p.TWO_PI);
                    const speed = p.random(0.5, 2);
                    
                    particles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: p.random(2, 6),
                        color: [...color, 200],
                        lifetime: 0,
                        maxLifetime: p.random(20, 60),
                        type: 'burst'
                    });
                }
            }
            
            function updateAndDrawParticles() {
                for (let i = particles.length - 1; i >= 0; i--) {
                    const particle = particles[i];
                    
                    // Update particle
                    particle.lifetime++;
                    
                    if (particle.type === 'burst') {
                        // Update burst particles
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                        particle.vx *= 0.95;
                        particle.vy *= 0.95;
                        particle.size *= 0.97;
                    } else {
                        // Update path particles
                        const path = particle.path;
                        
                        // Move along the path
                        particle.progress += particle.direction * particle.speed;
                        
                        // Constrain progress
                        particle.progress = p.constrain(particle.progress, 0, 1);
                        
                        // Calculate position along the bezier path
                        particle.x = p.bezierPoint(
                            path.start.x, path.controlPoint1.x, path.controlPoint2.x, path.end.x, 
                            particle.progress
                        );
                        particle.y = p.bezierPoint(
                            path.start.y, path.controlPoint1.y, path.controlPoint2.y, path.end.y, 
                            particle.progress
                        );
                    }
                    
                    // Calculate alpha based on lifetime
                    const alpha = particle.lifetime < particle.maxLifetime * 0.2 
                        ? p.map(particle.lifetime, 0, particle.maxLifetime * 0.2, 0, particle.color[3])
                        : p.map(particle.lifetime, particle.maxLifetime * 0.2, particle.maxLifetime, particle.color[3], 0);
                    
                    // Draw particle
                    p.noStroke();
                    p.fill(particle.color[0], particle.color[1], particle.color[2], alpha);
                    p.ellipse(particle.x, particle.y, particle.size, particle.size);
                    
                    // Remove if expired
                    if (particle.lifetime >= particle.maxLifetime) {
                        particles.splice(i, 1);
                    }
                }
            }
            
            function updateCentralNode() {
                // Pulsating effect
                centralNode.pulseAmount = 2 + p.sin(p.frameCount * 0.05) * 2;
                centralNode.size = centralNode.baseSize + centralNode.pulseAmount;
                
                // Rotation
                centralNode.rotation += centralNode.rotationSpeed;
                
                // During processing mode, make central node more active
                if (processingMode) {
                    centralNode.pulseAmount = 3 + p.sin(p.frameCount * 0.1) * 3;
                    centralNode.rotationSpeed = 0.01;
                } else {
                    centralNode.rotationSpeed = 0.005;
                }
            }
            
            function drawCentralNode() {
                p.push();
                p.translate(centralNode.x, centralNode.y);
                p.rotate(centralNode.rotation);
                
                // Draw glow
                for (let i = 4; i >= 0; i--) {
                    const glowSize = centralNode.size * (1 + i * 0.15);
                    const glowAlpha = 80 - i * 15;
                    p.fill(centralNode.color[0], centralNode.color[1], centralNode.color[2], glowAlpha);
                    p.noStroke();
                    drawPolygon(0, 0, glowSize, 8); // Octagon for central node
                }
                
                // Main shape
                p.fill(centralNode.color[0], centralNode.color[1], centralNode.color[2], centralNode.alpha);
                drawPolygon(0, 0, centralNode.size, 8);
                
                // Inner details
                p.fill(255, 255, 255, 40);
                drawPolygon(0, 0, centralNode.size * 0.7, 8);
                
                p.fill(centralNode.color[0], centralNode.color[1], centralNode.color[2], centralNode.alpha * 0.8);
                drawPolygon(0, 0, centralNode.size * 0.5, 8);
                
                p.fill(255, 255, 255, 70);
                drawPolygon(0, 0, centralNode.size * 0.3, 8);
                
                p.pop();
                
                // Draw connections to active hexagons
                for (let conn of centralNode.activeConnections) {
                    const target = conn.target;
                    
                    if (!target.active) continue;
                    
                    p.stroke(VIBRANT_TEAL[0], VIBRANT_TEAL[1], VIBRANT_TEAL[2], 80);
                    p.strokeWeight(2);
                    p.line(centralNode.x, centralNode.y, target.x, target.y);
                }
            }
            
            function createSolution() {
                // Find center point of active hexagons
                const activeHexagons = hexGrid.filter(h => h.active);
                
                if (activeHexagons.length < 5) return; // Need enough active hexagons
                
                let centerX = 0, centerY = 0;
                let totalWeight = 0;
                
                // Weighted center calculation giving more weight to hexagons closer to center
                for (let hex of activeHexagons) {
                    const distToCenter = p.dist(hex.x, hex.y, centralNode.x, centralNode.y);
                    const weight = 1 / (0.1 + distToCenter * 0.01);
                    centerX += hex.x * weight;
                    centerY += hex.y * weight;
                    totalWeight += weight;
                }
                
                centerX /= totalWeight;
                centerY /= totalWeight;
                
                // Create an emergent solution shape (crystal/star)
                emergedSolution = {
                    x: centerX,
                    y: centerY,
                    baseX: centerX,
                    baseY: centerY,
                    size: 0,
                    targetSize: 120,
                    points: p.floor(p.random(5, 9)), // 5-8 pointed star/crystal
                    innerRadius: 0.4, // Ratio for inner points
                    rotation: p.random(p.TWO_PI),
                    rotationSpeed: 0.002,
                    orbitSpeed: 0.01,
                    orbitRadius: 5,
                    orbitPhase: 0,
                    color: VIBRANT_TEAL,
                    alpha: 0,
                    growthProgress: 0,
                    particles: [],
                    connections: [],
                    rayEffects: []
                };
                
                // Create connections to active hexagons
                for (let hex of activeHexagons) {
                    if (p.random() < 0.7) { // Connect to most but not all hexagons
                        emergedSolution.connections.push({
                            target: hex,
                            strength: p.random(0.5, 1),
                            phase: p.random(p.TWO_PI),
                            pulseSpeed: p.random(0.03, 0.07)
                        });
                    }
                }
                
                // Create ray effects
                const numRays = p.floor(p.random(4, 8));
                for (let i = 0; i < numRays; i++) {
                    emergedSolution.rayEffects.push({
                        angle: p.TWO_PI * i / numRays,
                        length: p.random(100, 200),
                        width: p.random(1, 3),
                        phase: p.random(p.TWO_PI),
                        speed: p.random(0.03, 0.07)
                    });
                }
            }
            
            function updateAndDrawSolution() {
                if (!emergedSolution) return;
                
                // Update solution properties
                emergedSolution.growthProgress = Math.min(1, emergedSolution.growthProgress + 0.008);
                emergedSolution.size = p.lerp(0, emergedSolution.targetSize, emergedSolution.growthProgress);
                emergedSolution.alpha = p.lerp(0, 220, emergedSolution.growthProgress);
                emergedSolution.rotation += emergedSolution.rotationSpeed;
                
                // Orbital movement
                emergedSolution.orbitPhase += emergedSolution.orbitSpeed;
                emergedSolution.x = emergedSolution.baseX + Math.cos(emergedSolution.orbitPhase) * emergedSolution.orbitRadius;
                emergedSolution.y = emergedSolution.baseY + Math.sin(emergedSolution.orbitPhase) * emergedSolution.orbitRadius;
                
                // First draw ray effects behind
                drawSolutionRays();
                
                // Draw connections to hexagons
                drawSolutionConnections();
                
                // Draw the main solution shape
                p.push();
                p.translate(emergedSolution.x, emergedSolution.y);
                p.rotate(emergedSolution.rotation);
                
                // Draw outer glow
                for (let i = 4; i >= 0; i--) {
                    const glowSize = emergedSolution.size * (1 + i * 0.15);
                    const glowAlpha = Math.max(0, emergedSolution.alpha * 0.3 - i * 10);
                    
                    p.fill(emergedSolution.color[0], emergedSolution.color[1], emergedSolution.color[2], glowAlpha);
                    p.noStroke();
                    
                    drawStar(0, 0, glowSize, glowSize * emergedSolution.innerRadius, emergedSolution.points);
                }
                
                // Draw main shape
                p.fill(emergedSolution.color[0], emergedSolution.color[1], emergedSolution.color[2], emergedSolution.alpha);
                drawStar(0, 0, emergedSolution.size, emergedSolution.size * emergedSolution.innerRadius, emergedSolution.points);
                
                // Inner highlight for depth
                p.fill(255, 255, 255, 40);
                drawStar(0, 0, emergedSolution.size * 0.7, emergedSolution.size * 0.7 * emergedSolution.innerRadius, emergedSolution.points);
                
                // Core
                p.fill(emergedSolution.color[0], emergedSolution.color[1], emergedSolution.color[2], emergedSolution.alpha * 0.8);
                drawStar(0, 0, emergedSolution.size * 0.4, emergedSolution.size * 0.4 * emergedSolution.innerRadius, emergedSolution.points);
                
                p.fill(255, 255, 255, 70);
                p.ellipse(0, 0, emergedSolution.size * 0.2, emergedSolution.size * 0.2);
                
                p.pop();
                
                // Occasionally emit particles
                if (processingMode && emergedSolution.growthProgress > 0.5 && p.frameCount % 5 === 0) {
                    emitSolutionParticles();
                }
                
                // If solution is fully grown and processing is done, start fading it out
                if (emergedSolution.growthProgress >= 1 && !processingMode) {
                    emergedSolution.alpha = Math.max(0, emergedSolution.alpha - 1);
                    
                    // Remove solution when fully faded
                    if (emergedSolution.alpha <= 0) {
                        emergedSolution = null;
                    }
                }
            }
            
            function drawSolutionRays() {
                if (!emergedSolution || !emergedSolution.rayEffects) return;
                
                for (let ray of emergedSolution.rayEffects) {
                    // Calculate pulsating effect
                    const pulseEffect = 0.5 + 0.5 * Math.sin(p.frameCount * ray.speed + ray.phase);
                    const rayLength = ray.length * pulseEffect * emergedSolution.growthProgress;
                    const alpha = 120 * pulseEffect * emergedSolution.growthProgress;
                    
                    // Calculate start and end points
                    const startX = emergedSolution.x;
                    const startY = emergedSolution.y;
                    const endX = startX + Math.cos(ray.angle) * rayLength;
                    const endY = startY + Math.sin(ray.angle) * rayLength;
                    
                    // Draw ray with gradient
                    for (let i = 0; i < 3; i++) {
                        const rayWidth = ray.width * (3 - i) * pulseEffect;
                        p.stroke(emergedSolution.color[0], emergedSolution.color[1], emergedSolution.color[2], alpha * (3-i)/3);
                        p.strokeWeight(rayWidth);
                        p.line(startX, startY, endX, endY);
                    }
                }
            }
            
            function drawSolutionConnections() {
                if (!emergedSolution || !emergedSolution.connections) return;
                
                for (let conn of emergedSolution.connections) {
                    // Skip if target is no longer active
                    if (!conn.target.active) continue;
                    
                    // Calculate pulsating effect
                    const pulseEffect = 0.3 + 0.7 * Math.sin(p.frameCount * conn.pulseSpeed + conn.phase);
                    const alpha = 150 * pulseEffect * emergedSolution.growthProgress;
                    
                    // Draw curved connection
                    p.noFill();
                    
                    // Draw multiple layers for glow effect
                    for (let i = 0; i < 3; i++) {
                        const connWidth = (3 - i) * pulseEffect;
                        p.stroke(emergedSolution.color[0], emergedSolution.color[1], emergedSolution.color[2], alpha * (3-i)/3);
                        p.strokeWeight(connWidth);
                        
                        // Calculate midpoint with offset for curve
                        const midX = (emergedSolution.x + conn.target.x) / 2;
                        const midY = (emergedSolution.y + conn.target.y) / 2;
                        const perpAngle = Math.atan2(conn.target.y - emergedSolution.y, conn.target.x - emergedSolution.x) + Math.PI/2;
                        const offsetDist = p.dist(emergedSolution.x, emergedSolution.y, conn.target.x, conn.target.y) * 0.2;
                        const ctrlX = midX + Math.cos(perpAngle) * offsetDist * pulseEffect;
                        const ctrlY = midY + Math.sin(perpAngle) * offsetDist * pulseEffect;
                        
                        p.beginShape();
                        p.vertex(emergedSolution.x, emergedSolution.y);
                        p.quadraticVertex(ctrlX, ctrlY, conn.target.x, conn.target.y);
                        p.endShape();
                    }
                    
                    // Draw moving particles along the connection
                    if (processingMode) {
                        const t = (p.frameCount * 0.01) % 1;
                        const ptX = p.bezierPoint(emergedSolution.x, ctrlX, conn.target.x, t);
                        const ptY = p.bezierPoint(emergedSolution.y, ctrlY, conn.target.y, t);
                        
                        p.noStroke();
                        p.fill(255, 255, 255, alpha);
                        p.ellipse(ptX, ptY, 4 * pulseEffect, 4 * pulseEffect);
                    }
                }
            }
            
            function emitSolutionParticles() {
                const numParticles = p.floor(p.random(1, 4));
                
                for (let i = 0; i < numParticles; i++) {
                    const angle = p.random(p.TWO_PI);
                    const speed = p.random(0.5, 2);
                    
                    particles.push({
                        x: emergedSolution.x,
                        y: emergedSolution.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: p.random(3, 7),
                        color: [
                            emergedSolution.color[0] + p.random(-20, 20),
                            emergedSolution.color[1] + p.random(-20, 20),
                            emergedSolution.color[2] + p.random(-20, 20),
                            200
                        ],
                        lifetime: 0,
                        maxLifetime: p.random(30, 90),
                        type: 'burst'
                    });
                }
            }
            
            function drawStar(x, y, radius1, radius2, npoints) {
                p.beginShape();
                for (let i = 0; i < npoints * 2; i++) {
                    const angle = p.map(i, 0, npoints * 2, 0, p.TWO_PI);
                    const radius = i % 2 === 0 ? radius1 : radius2;
                    const sx = x + p.cos(angle) * radius;
                    const sy = y + p.sin(angle) * radius;
                    p.vertex(sx, sy);
                }
                p.endShape(p.CLOSE);
            }
            
            function triggerProcessingMode() {
                processingMode = true;
                processingTimer = 0;
                solutionPhase = false;
                
                // Activate several random hexagons to start
                const inactiveHexagons = hexGrid.filter(h => !h.active);
                const numToActivate = Math.min(7, inactiveHexagons.length);
                
                for (let i = 0; i < numToActivate; i++) {
                    const index = p.floor(p.random(inactiveHexagons.length));
                    inactiveHexagons[index].active = true;
                    inactiveHexagons[index].highlight = 80;
                    
                    // Create particles at activation point
                    createMergeParticles(
                        inactiveHexagons[index].x, 
                        inactiveHexagons[index].y, 
                        inactiveHexagons[index].color,
                        8
                    );
                    
                    inactiveHexagons.splice(index, 1); // Remove from array to avoid duplicates
                }
            }
            
            function resetProcessing() {
                processingMode = false;
                processingTimer = 0;
                
                // Clear most pathways
                pathways = pathways.filter(path => p.random() < 0.2); // Keep a few
                
                // Deactivate all hexagons gradually
                for (let hex of hexGrid) {
                    if (p.random() < 0.7) { // Keep some active for visual interest
                        hex.active = false;
                    }
                }
                
                // Clear central node connections
                centralNode.activeConnections = [];
            }
            
            p.windowResized = function() {
                let container = document.getElementById('visualization-container');
                p.resizeCanvas(container.offsetWidth, container.offsetHeight);
                
                // Update central node position
                centralNode.x = p.width / 2;
                centralNode.y = p.height / 2;
                
                // Recalculate hexagon positions relative to new center
                for (let hex of hexGrid) {
                    const angle = Math.atan2(hex.y - centralNode.y, hex.x - centralNode.x);
                    const dist = p.dist(hex.x, hex.y, centralNode.x, centralNode.y);
                    
                    hex.angleFromCenter = angle;
                    hex.distanceFromCenter = dist;
                    hex.baseX = centralNode.x + Math.cos(angle) * dist;
                    hex.baseY = centralNode.y + Math.sin(angle) * dist;
                }
            };
            
            p.mousePressed = function() {
                if (p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height) {
                    // When mouse is pressed inside visualization area
                    
                    // Set mouse influence position
                    mouseInfluence.x = p.mouseX;
                    mouseInfluence.y = p.mouseY;
                    mouseInfluence.active = true;
                    
                    // If not in processing mode, trigger it
                    if (!processingMode) {
                        triggerProcessingMode();
                    }
                    
                    return false; // Prevent default
                }
            };
            
            p.mouseReleased = function() {
                // Turn off mouse influence
                mouseInfluence.active = false;
                return false; // Prevent default
            };
            
            p.mouseDragged = function() {
                if (mouseInfluence.active) {
                    // Update mouse influence position
                    mouseInfluence.x = p.mouseX;
                    mouseInfluence.y = p.mouseY;
                    
                    return false; // Prevent default
                }
            };
        };
        
        // Start the P5 sketch in the visualization container
        new p5(geminiSketch, 'visualization-container');
    </script>
</body>
</html>
