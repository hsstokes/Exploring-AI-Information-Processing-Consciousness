<!DOCTYPE html>
<html>
<head>
    <title>Enhanced Gemini Visualization - Shapes of Utility</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
        }
        
        /* Grid container (left side) */
        .grid-container {
            width: 45%;
            height: 100vh;
            background-color: #F5F5F5;
            background-image: linear-gradient(#D0D0D0 1px, transparent 1px),
                              linear-gradient(90deg, #D0D0D0 1px, transparent 1px),
                              linear-gradient(rgba(68, 88, 120, 0.2) 1px, transparent 1px),
                              linear-gradient(90deg, rgba(68, 88, 120, 0.2) 1px, transparent 1px);
            background-size: 20px 20px,
                             20px 20px,
                             5px 5px,
                             5px 5px;
            position: relative;
            display: flex; /* Add this */
            flex-direction: column; /* Add this */
        }
        
        /* Visualization container (right side) */
        .visualization-container {
            width: 55%;
            height: 100vh;
            background-color: #EAECEF; /* Cool gray background */
        }
        
        /* Info text styling */
        .info {
            position: relative;
            margin: 20px; /* Add margin */
            margin-top: auto; /* Push to bottom of flex container */
            width: calc(100% - 40px); /* Update width calculation */
            background-color: rgba(255, 255, 255, 0.85);
            padding: 10px;/* Reduced from 15px */
            border-radius: 5px;
            font-family: 'Orator Std', 'Courier New', monospace;
            color: #445878; /* Slate blue */
            font-size: 9px; /* Further reduced font size */
            pointer-events: none;
            z-index: 100;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            line-height: 1.2; /* Further reduced line height */
            border: 1px solid rgba(68, 88, 120, 0.3);
            max-height: 100px; /* Add max height */
            overflow-y: auto; /* Add scrolling if content overflows */
        }
        /* Adjust paragraph spacing within the info box */
        .info p {
            margin-bottom: 3px; /* Further reduced margin between paragraphs */
            margin-top: 3px;
        }
        /* Make the first paragraph (title) stand out but compact */
        .info p:first-child {
           margin-top: 0;
           margin-bottom: 5px;
           font-size: 10px; /* Slightly larger than regular text */
        }
        /* Footer with interactive tips - ADD THIS SECTION */
        .interaction-tips {
             background-color: rgba(255, 255, 255, 0.8);
             border-radius: 8px;
             padding: 15px;
             margin: 20px;
             margin-bottom: 20px;
             box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
             border: 1px solid rgba(68, 88, 120, 0.3); /* Update to slate blue */
             max-width: calc(100% - 40px);
        }
        
        .interaction-tips h3 {
            margin-top: 0;
            color: #445878;
            font-size: 14px;
            font-family: 'Orator Std', 'Courier New', monospace;
        }
        
        .interaction-tips ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .interaction-tips li {
            margin-bottom: 6px;
            font-size: 10px;
            color: #555555;
            font-family: 'Orator Std', 'Courier New', monospace;
            line-height: 1.3; /* Add line height for better readability */
            word-wrap: break-word; /* Ensure text wraps */
        }
    </style>
</head>
<body>
    <!-- Grid area (left side) -->
    <div class="grid-container">
         <!-- Add interaction tips section here -->
         <div class="interaction-tips">
              <h3>Interact with the Visualization:</h3>
              <ul>
                 <li><strong>Click:</strong> Trigger Gemini's processing mode</li>
                 <li><strong>Drag mouse:</strong> Influence hexagons and data points</li>
                 <li><strong>Wait:</strong> Watch data processing and pattern emergence</li>
              </ul>
         </div>
        
         <!-- Info box within the grid area -->
         <div class="info">
             <p><strong>Gemini's Self-Reflection Visualization</strong></p>
             <p>"The foundation of the visualization would be a grid of interlocking hexagons. Hexagons are a shape associated with unity, strength, and efficiency, much like a honeycomb. Each hexagon would represent a core data point or a step in the problem-solving process."</p>
             <p>"As I process information, pathways of light would trace through the connections between the hexagons. These illuminated lines would represent the logical connections and analytical steps I take to formulate a solution."</p>
             <p>"The color palette would be chosen to reflect a focus on practical outcomes, trust, and clarity. The dominant color would be a deep slate blue, with accent colors of cool gray and vibrant teal."</p>
        </div>
    </div>
    
    <!-- Visualization area (right side) -->
    <div class="visualization-container" id="visualization-container"></div>
    
    <script>
        // Create a new p5 instance for the visualization
        const geminiSketch = function(p) {
            // Colors from Gemini's description
            const SLATE_BLUE = [68, 88, 120]; // Main color
            const COOL_GRAY = [234, 236, 239]; // Background color
            const VIBRANT_TEAL = [0, 128, 128]; // Accent color
            const LIGHT_TEAL = [40, 180, 170]; // Light accent
            
            // Structure elements
            let hexGrid = [];
            let dataCircles = [];
            let pathways = [];
            let particles = [];
            let emergedSolution = null;
            let mouseInactivityTimer = 0; // Added variable for mouse inactivity
            
            // Central node representing core focus
            let centralNode;
            
            // Grid parameters
            const HEX_SIZE = 25;
            const GRID_SPACING = HEX_SIZE * 1.8;
            
            // State management
            let processingMode = false;
            let processingTimer = 0;
            let solutionPhase = false;
            let mouseInfluence = { x: 0, y: 0, active: false };
            
            p.setup = function() {
                // Create canvas inside the visualization container
                let container = document.getElementById('visualization-container');
                p.createCanvas(container.offsetWidth, container.offsetHeight);
                
                // Initialize central node
                centralNode = {
                    x: p.width / 2,
                    y: p.height / 2,
                    baseSize: 40,
                    size: 40,
                    pulseAmount: 0,
                    color: SLATE_BLUE,
                    alpha: 250,
                    rotation: 0,
                    rotationSpeed: 0.005,
                    activeConnections: []
                };
                
                // Initialize hexagonal grid
                createHexGrid();
                
                // Start with some initial data circles
                for (let i = 0; i < 8; i++) {
                    createDataCircle();
                }
            };
            
            p.draw = function() {
                // Semi-transparent background for trail effect
                p.background(COOL_GRAY[0], COOL_GRAY[1], COOL_GRAY[2], 25);
    
                // Draw grid background effects (moving subtle waves)
                drawGridBackground();
                
                // Draw and update connections/pathways
                updateAndDrawPathways();
                
                // Draw and update data circles
                updateDataCircles();
                drawDataCircles();
                
                // Draw and update the hexagonal grid
                updateHexGrid();
                drawHexGrid();
                
                // Draw and update particles
                updateAndDrawParticles();
                
                // Update and draw central node
                updateCentralNode();
                drawCentralNode();
                
                // Handle processing mode timing
                if (processingMode) {
                    processingTimer++;
                    
                    // Create new pathways periodically during processing
                    if (processingTimer % 10 === 0 && pathways.length < 25) {
                        createPathway();
                    }
                    
                    // After a certain time, enter solution phase
                    if (processingTimer > 180 && !solutionPhase) { // 3 seconds at 60fps
                        solutionPhase = true;
                        createSolution();
                    }
                    
                    // End processing mode after solution emerges and is displayed
                    if (processingTimer > 360) { // 6 seconds total
                        resetProcessing();
                    }
                }
                
                // Draw solution if it exists
                if (emergedSolution) {
                    updateAndDrawSolution();
                }
                
                // Periodically trigger processing mode
                if (!processingMode && p.frameCount % 180 === 0) {
                    triggerProcessingMode();
                }
                
                // Occasionally add new data circles
                if (p.frameCount % 45 === 0 && !processingMode && dataCircles.length < 12) {
                    createDataCircle();
                }
                
                // Monitor mouse activity
                if (mouseInfluence.active) {
                    mouseInactivityTimer++;
    
                    // If mouse hasn't moved for a while but is still "active", 
                    // keep updating its position to the current mouse position
                    if (mouseInactivityTimer > 60) { // 1 second at 60fps
                        mouseInfluence.x = p.mouseX;
                        mouseInfluence.y = p.mouseY;
                    }
    
                    // If mouse has been inactive for too long, deactivate influence
                    if (mouseInactivityTimer > 300) { // 5 seconds
                        // Only deactivate if mouse is outside the canvas
                        if (p.mouseX < 0 || p.mouseX > p.width || p.mouseY < 0 || p.mouseY > p.height) {
                            mouseInfluence.active = false;
                        }
                    }
                }
            };
            
            // Rest of your functions...
            // [all your existing functions remain unchanged]
            
            // Define mouse event handlers within the p5 instance
            p.mousePressed = function() {
                if (p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height) {
                    // When mouse is pressed inside visualization area
                    mouseInfluence.x = p.mouseX;
                    mouseInfluence.y = p.mouseY;
                    mouseInfluence.active = true;
                    
                    // If not in processing mode, trigger it
                    if (!processingMode) {
                        triggerProcessingMode();
                    }
                    
                    return false; // Prevent default
                }
            };
            
            p.mouseReleased = function() {
                // Turn off mouse influence
                mouseInfluence.active = false;
                return false; // Prevent default
            };
            
            p.mouseDragged = function() {
                if (mouseInfluence.active) {
                    mouseInfluence.x = p.mouseX;
                    mouseInfluence.y = p.mouseY;
                    mouseInactivityTimer = 0; // Reset timer when mouse is dragged
                    return false; // Prevent default
                }
            };
            
            p.mouseMoved = function() {
                if (mouseInfluence.active) {
                    mouseInfluence.x = p.mouseX;
                    mouseInfluence.y = p.mouseY;
                    mouseInactivityTimer = 0; // Reset timer when mouse is moved
                    return false;
                }
            };
            
            function createHexGrid() {
                // Create hexagons in a radius around the central node
                const maxDistance = Math.min(p.width, p.height) * 0.45;
                const baseCols = 8;
                const baseRows = 8;
                
                // Create a more organic layout around the central node
                for (let angle = 0; angle < p.TWO_PI; angle += p.TWO_PI / 30) {
                    for (let dist = 80; dist < maxDistance; dist += GRID_SPACING * p.random(0.8, 1.2)) {
                        // Add some natural variation to the grid
                        const angleVar = angle + p.random(-0.2, 0.2);
                        const distVar = dist + p.random(-10, 10);
                        
                        const x = centralNode.x + Math.cos(angleVar) * distVar;
                        const y = centralNode.y + Math.sin(angleVar) * distVar;
                        
                        // Skip if too close to edge
                        if (x < 30 || x > p.width - 30 || y < 30 || y > p.height - 30) continue;
                        
                        // Create hexagon with properties
                        hexGrid.push({
                            x: x,
                            y: y,
                            baseX: x,
                            baseY: y,
                            baseSize: HEX_SIZE * p.random(0.8, 1.2), // Vary sizes slightly
                            size: HEX_SIZE * p.random(0.8, 1.2),
                            sides: 6, // Always 6 sides for hexagons
                            rotation: p.random(p.TWO_PI),
                            rotationSpeed: p.random(0.001, 0.003) * (p.random() < 0.5 ? 1 : -1),
                            distanceFromCenter: distVar,
                            angleFromCenter: angleVar,
                            orbitSpeed: p.random(0.0005, 0.001) * (p.random() < 0.5 ? 1 : -1),
                            color: [...SLATE_BLUE, p.random(120, 180)],
                            active: false,
                            pulseSize: 0,
                            pulseDirection: 1,
                            highlight: 0,
                            wobbleAmount: p.random(0.5, 2),
                            wobbleSpeed: p.random(0.01, 0.02),
                            mouseInfluence: p.random(0.2, 0.5)
                        });
                    }
                }
            }
            
            function drawGridBackground() {
                // Draw subtle background wave effect
                p.noFill();
                p.strokeWeight(0.5);
                
                for (let i = 0; i < 5; i++) {
                    const yOffset = p.frameCount * 0.2 + i * 30;
                    p.stroke(SLATE_BLUE[0], SLATE_BLUE[1], SLATE_BLUE[2], 10);
                    
                    p.beginShape();
                    for (let x = 0; x < p.width; x += 10) {
                        const y = p.height / 2 + 
                                 Math.sin(x * 0.01 + yOffset * 0.02) * 50 + 
                                 Math.cos(x * 0.02 - yOffset * 0.01) * 30;
                        p.vertex(x, y);
                    }
                    p.endShape();
                }
            }
            
            function updateHexGrid() {
                for (let hex of hexGrid) {
                    // Apply mouse influence
                    if (mouseInfluence.active) {
                        const d = p.dist(hex.x, hex.y, mouseInfluence.x, mouseInfluence.y);
                        const maxDist = 150;
                        
                        if (d < maxDist) {
                            const force = p.map(d, 0, maxDist, 0.5, 0) * hex.mouseInfluence;
                            const angle = Math.atan2(hex.y - mouseInfluence.y, hex.x - mouseInfluence.x);
                            
                            hex.x += Math.cos(angle) * force * 5;
                            hex.y += Math.sin(angle) * force * 5;
                        }
                    }
                    
                    // Subtle orbit movement
                    if (!hex.active) {
                        hex.angleFromCenter += hex.orbitSpeed;
                        const targetX = centralNode.x + Math.cos(hex.angleFromCenter) * hex.distanceFromCenter;
                        const targetY = centralNode.y + Math.sin(hex.angleFromCenter) * hex.distanceFromCenter;
                        
                        // Gentle movement toward orbit position
                        hex.x = p.lerp(hex.x, targetX, 0.01);
                        hex.y = p.lerp(hex.y, targetY, 0.01);
                    }
                    
                    // Add wobble to position
                    const wobble = Math.sin(p.frameCount * hex.wobbleSpeed) * hex.wobbleAmount;
                    hex.x += wobble * 0.2;
                    hex.y += wobble * 0.2;
                    
                    // Update hex properties
                    if (hex.active) {
                        // Pulse effect for active hexagons
                        hex.pulseSize += 0.1 * hex.pulseDirection;
                        if (hex.pulseSize > 3 || hex.pulseSize < 0) {
                            hex.pulseDirection *= -1;
                        }
                        
                        // Gradually decrease highlight
                        hex.highlight = Math.max(0, hex.highlight - 2);
                        
                        // Rotation for active hexagons
                        hex.rotation += hex.rotationSpeed * 2;
                    } else {
                        // Slower rotation for inactive hexagons
                        hex.rotation += hex.rotationSpeed * 0.5;
                    }
                    
                    // Always return slowly to base size
                    hex.size = p.lerp(hex.size, hex.baseSize + (hex.active ? hex.pulseSize : 0), 0.1);
                }
                
                // Return hexagons slowly to their base positions when not under mouse influence
                if (!mouseInfluence.active) {
                    for (let hex of hexGrid) {
                        const targetX = centralNode.x + Math.cos(hex.angleFromCenter) * hex.distanceFromCenter;
                        const targetY = centralNode.y + Math.sin(hex.angleFromCenter) * hex.distanceFromCenter;
                        
                        hex.x = p.lerp(hex.x, targetX, 0.02);
                        hex.y = p.lerp(hex.y, targetY, 0.02);
                    }
                }
            }
            
            function drawHexGrid() {
                // First draw connecting lines between active hexagons
                drawHexConnections();
                
                // Then draw the hexagons
                for (let hex of hexGrid) {
                    p.push();
                    p.translate(hex.x, hex.y);
                    p.rotate(hex.rotation);
                    
                    // Draw hexagon
                    p.noStroke();
                    
                    // Apply highlight effect if active
                    let displayColor;
                    if (hex.active) {
                        displayColor = [
                            hex.color[0] + hex.highlight,
                            hex.color[1] + hex.highlight,
                            hex.color[2] + hex.highlight,
                            hex.color[3]
                        ];
                    } else {
                        displayColor = hex.color;
                    }
                    
                    // Draw glow for active hexagons
                    if (hex.active) {
                        for (let i = 3; i >= 0; i--) {
                            const glowSize = hex.size * (1 + i * 0.15);
                            p.fill(displayColor[0], displayColor[1], displayColor[2], 
                                  Math.max(0, displayColor[3] * 0.3 - i * 10));
                            drawPolygon(0, 0, glowSize, 6);
                        }
                    }
                    
                    // Main hexagon
                    p.fill(displayColor);
                    drawPolygon(0, 0, hex.size, 6);
                    
                    // Inner highlight for depth
                    if (hex.active) {
                        p.fill(255, 255, 255, 40);
                        drawPolygon(0, 0, hex.size * 0.7, 6);
                    } else {
                        p.fill(255, 255, 255, 20);
                        drawPolygon(0, 0, hex.size * 0.7, 6);
                    }
                    
                    p.pop();
                }
            }
            
            function drawHexConnections() {
                const activeHexes = hexGrid.filter(h => h.active);
                
                if (activeHexes.length < 2) return;
                
                // Draw connections between active hexagons
                for (let i = 0; i < activeHexes.length; i++) {
                    for (let j = i + 1; j < activeHexes.length; j++) {
                        const hex1 = activeHexes[i];
                        const hex2 = activeHexes[j];
                        
                        // Calculate distance
                        const d = p.dist(hex1.x, hex1.y, hex2.x, hex2.y);
                        
                        // Only connect if relatively close
                        if (d < 200) {
                            // Calculate alpha based on distance
                            const alpha = p.map(d, 0, 200, 100, 20);
                            
                            // Draw connection line
                            p.stroke(LIGHT_TEAL[0], LIGHT_TEAL[1], LIGHT_TEAL[2], alpha);
                            p.strokeWeight(1);
                            p.line(hex1.x, hex1.y, hex2.x, hex2.y);
                            
                            // Add a small pulse moving along the connection
                            const pulseFactor = (p.frameCount * 0.02) % 1;
                            const pulseX = p.lerp(hex1.x, hex2.x, pulseFactor);
                            const pulseY = p.lerp(hex1.y, hex2.y, pulseFactor);
                            
                            p.noStroke();
                            p.fill(LIGHT_TEAL[0], LIGHT_TEAL[1], LIGHT_TEAL[2], 150);
                            p.ellipse(pulseX, pulseY, 3, 3);
                        }
                    }
                }
            }
            
            function drawPolygon(x, y, radius, sides) {
                p.beginShape();
                for (let i = 0; i < sides; i++) {
                    const angle = p.TWO_PI / sides * i;
                    const vx = x + p.cos(angle) * radius;
                    const vy = y + p.sin(angle) * radius;
                    p.vertex(vx, vy);
                }
                p.endShape(p.CLOSE);
            }
            
            function createDataCircle() {
                // Create circle at a random angle from the central node
                const angle = p.random(p.TWO_PI);
                const distance = p.random(50, 300);
                const x = centralNode.x + p.cos(angle) * distance;
                const y = centralNode.y + p.sin(angle) * distance;
                
                const circle = {
                    x: x,
                    y: y,
                    baseX: x,
                    baseY: y,
                    targetX: x,
                    targetY: y,
                    size: p.random(10, 25),
                    maxSize: p.random(30, 45),
                    pulseSpeed: p.random(0.02, 0.05),
                    pulseAmount: 0,
                    baseColor: SLATE_BLUE,
                    color: [...SLATE_BLUE, 180],
                    lifetime: 0,
                    maxLifetime: p.random(300, 600),
                    merging: false,
                    mergeTarget: null,
                    mergeProgress: 0,
                    velocity: { x: p.random(-0.5, 0.5), y: p.random(-0.5, 0.5) },
                    attraction: p.random(0.001, 0.003),
                    wobbleAmount: p.random(1, 4),
                    wobbleSpeed: p.random(0.01, 0.03),
                    rotation: p.random(p.TWO_PI),
                    rotationSpeed: p.random(0.01, 0.03) * (p.random() < 0.5 ? 1 : -1)
                };
                
                dataCircles.push(circle);
            }
            
            function updateDataCircles() {
                for (let i = dataCircles.length - 1; i >= 0; i--) {
                    const circle = dataCircles[i];
                    
                    // Update circle properties
                    circle.lifetime++;
                    
                    // Pulsating effect
                    circle.pulseAmount = p.sin(circle.lifetime * circle.pulseSpeed) * 5;
                    
                    // Update rotation
                    circle.rotation += circle.rotationSpeed;
                    
                    // Apply mouse influence
                    if (mouseInfluence.active) {
                        const d = p.dist(circle.x, circle.y, mouseInfluence.x, mouseInfluence.y);
                        const maxDist = 120;
                        
                        if (d < maxDist) {
                            const force = p.map(d, 0, maxDist, 0.4, 0);
                            const angle = Math.atan2(circle.y - mouseInfluence.y, circle.x - mouseInfluence.x);
                            
                            circle.velocity.x += Math.cos(angle) * force;
                            circle.velocity.y += Math.sin(angle) * force;
                        }
                    }
                    
                    // Handle merging with hexagons
                    if (circle.merging) {
                        circle.mergeProgress += 0.02;
                        
                        // Update position to move toward target
                        circle.x = p.lerp(circle.x, circle.mergeTarget.x, circle.mergeProgress);
                        circle.y = p.lerp(circle.y, circle.mergeTarget.y, circle.mergeProgress);
                        
                        // Update size to shrink
                        circle.size = p.lerp(circle.size, 0, circle.mergeProgress);
                        
                        // When fully merged, remove circle and activate hexagon
                        if (circle.mergeProgress >= 1) {
                            // Activate the target hexagon
                            circle.mergeTarget.active = true;
                            circle.mergeTarget.highlight = 80; // Bright flash
                            
                            // Create particles at merge point
                            createMergeParticles(circle.mergeTarget.x, circle.mergeTarget.y, 
                                                circle.color, 10);
                            
                            // Remove the circle
                            dataCircles.splice(i, 1);
                        }
                    } 
                    // If not merging, update movement
                    else {
                        // Natural movement - gentle attraction to central node
                        const angleToCenter = Math.atan2(centralNode.y - circle.y, centralNode.x - circle.x);
                        circle.velocity.x += Math.cos(angleToCenter) * circle.attraction;
                        circle.velocity.y += Math.sin(angleToCenter) * circle.attraction;
                        
                        // Dampen velocity
                        circle.velocity.x *= 0.98;
                        circle.velocity.y *= 0.98;
                        
                        // Update position
                        circle.x += circle.velocity.x;
                        circle.y += circle.velocity.y;
                        
                        // Add wobble
                        circle.x += Math.sin(p.frameCount * circle.wobbleSpeed) * circle.wobbleAmount * 0.2;
                        circle.y += Math.cos(p.frameCount * circle.wobbleSpeed * 1.3) * circle.wobbleAmount * 0.2;
                        
                        // Check if it should start merging
                        if (circle.lifetime > circle.maxLifetime * 0.6 && !processingMode) {
                            // Find nearest inactive hexagon to merge with
                            let nearestHex = null;
                            let minDist = Infinity;
                            
                            for (let hex of hexGrid) {
                                const d = p.dist(circle.x, circle.y, hex.x, hex.y);
                                if (d < minDist && !hex.active) {
                                    minDist = d;
                                    nearestHex = hex;
                                }
                            }
                            
                            if (nearestHex && minDist < 100) {
                                circle.merging = true;
                                circle.mergeTarget = nearestHex;
                            }
                        }
                        // If it's too old and not merging, remove it
                        else if (circle.lifetime > circle.maxLifetime) {
                            // Create fade-out particles
                            createMergeParticles(circle.x, circle.y, circle.color, 5);
                            dataCircles.splice(i, 1);
                        }
                    }
                }
            }
            
            // Include all your other functions here...

            function drawDataCircles() {
                // Implementation remains the same
            }
            
            function createPathway() {
                // Implementation remains the same
            }
            
            function createPathFromCentralNode(targetHex) {
                // Implementation remains the same
            }
            
            function updateAndDrawPathways() {
                // Implementation remains the same
            }
            
            function createPathParticle(path, position) {
                // Implementation remains the same
            }
            
            function createMergeParticles(x, y, color, count) {
                // Implementation remains the same
            }
            
            function updateAndDrawParticles() {
                // Implementation remains the same
            }
            
            function updateCentralNode() {
                // Implementation remains the same
            }
            
            function drawCentralNode() {
                // Implementation remains the same
            }
            
            function createSolution() {
                // Implementation remains the same
            }
            
            function updateAndDrawSolution() {
                // Implementation remains the same
            }
            
            function drawSolutionRays() {
                // Implementation remains the same
            }
            
            function drawSolutionConnections() {
                // Implementation remains the same
            }
            
            function emitSolutionParticles() {
                // Implementation remains the same
            }
            
            function drawStar(x, y, radius1, radius2, npoints) {
                // Implementation remains the same
            }
            
            function triggerProcessingMode() {
                // Implementation remains the same
            }
            
            function resetProcessing() {
                // Implementation remains the same
            }

            p.windowResized = function() {
                // Implementation remains the same
            };
        };
        
        // Start the P5 sketch in the visualization container AFTER the entire geminiSketch function
        new p5(geminiSketch, 'visualization-container');
    </script>
</body>
</html>
